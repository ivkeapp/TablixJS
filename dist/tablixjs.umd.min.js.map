{"version":3,"file":"tablixjs.umd.min.js","sources":["../src/core/DataManager.js","../src/core/Renderer.js","../src/core/EventManager.js","../src/core/PaginationManager.js","../src/core/SortingManager.js","../src/core/ColumnManager.js","../src/core/FilterManager.js","../src/core/FilterUI.js","../src/core/SearchManager.js","../src/core/SelectionManager.js","../src/core/VirtualScroll.js","../src/core/Table.js","../src/index.js"],"sourcesContent":["export default class DataManager {\r\n  constructor(table, data = []) {\r\n    this.table = table;\r\n    this.originalData = data;   // full data set\r\n    this.filteredData = [...data];  // filtered data\r\n    this.currentFilters = {};   // current filter criteria\r\n    this.currentSorts = [];     // current sort criteria (deprecated - use SortingManager)\r\n    this.serverTotalRows = null; // for server-side pagination\r\n  }\r\n\r\n  getData() {\r\n    return this.filteredData;\r\n  }\r\n\r\n  setData(data) {\r\n    this.originalData = data;\r\n    this.filteredData = [...data];\r\n    \r\n    // Update pagination info after data change\r\n    if (this.table.paginationManager) {\r\n      this.table.paginationManager.updatePaginationInfo();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set data from server (for server-side operations)\r\n   */\r\n  setServerData(data, totalRows = null) {\r\n    this.originalData = data;\r\n    this.filteredData = [...data];\r\n    this.serverTotalRows = totalRows;\r\n    \r\n    // Update pagination info after data change\r\n    if (this.table.paginationManager) {\r\n      this.table.paginationManager.updatePaginationInfo(totalRows);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get total rows (for server-side pagination)\r\n   */\r\n  getTotalRows() {\r\n    return this.serverTotalRows !== null ? this.serverTotalRows : this.originalData.length;\r\n  }\r\n\r\n  applyFilter(criteria) {\r\n    this.currentFilters = criteria;\r\n    \r\n    if (Object.keys(criteria).length === 0) {\r\n      // No filters, show all data\r\n      this.filteredData = [...this.originalData];\r\n    } else {\r\n      // Simple filtering: supports multiple criteria (legacy format)\r\n      this.filteredData = this.originalData.filter(item => {\r\n        return Object.entries(criteria).every(([key, value]) => {\r\n          const itemValue = (item[key] + '').toLowerCase();\r\n          const searchValue = (value + '').toLowerCase();\r\n          return itemValue.includes(searchValue);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Reset pagination to first page after filtering\r\n    if (this.table.paginationManager) {\r\n      this.table.paginationManager.resetToFirstPage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply filtering from FilterManager (this will be called by FilterManager)\r\n   * @param {Array} filteredData - Pre-filtered data from FilterManager\r\n   */\r\n  setFilteredData(filteredData) {\r\n    this.filteredData = filteredData;\r\n    \r\n    // Reset pagination to first page after filtering\r\n    if (this.table.paginationManager) {\r\n      this.table.paginationManager.resetToFirstPage();\r\n    }\r\n  }\r\n\r\n  applySorting(sorts) {\r\n    this.currentSorts = sorts;\r\n    \r\n    if (!sorts || sorts.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Use SortingManager if available, otherwise fall back to basic sorting\r\n    if (this.table.sortingManager && this.table.sortingManager.currentSorts.length > 0) {\r\n      this.table.sortingManager._applySorting();\r\n    } else {\r\n      // Legacy sorting implementation\r\n      this.filteredData.sort((a, b) => {\r\n        for (const sort of sorts) {\r\n          const { column, direction } = sort;\r\n          const aVal = a[column];\r\n          const bVal = b[column];\r\n          \r\n          let comparison = 0;\r\n          if (aVal < bVal) comparison = -1;\r\n          else if (aVal > bVal) comparison = 1;\r\n          \r\n          if (comparison !== 0) {\r\n            return direction === 'desc' ? -comparison : comparison;\r\n          }\r\n        }\r\n        return 0;\r\n      });\r\n    }\r\n\r\n    // Reset pagination to first page after sorting\r\n    if (this.table.paginationManager) {\r\n      this.table.paginationManager.resetToFirstPage();\r\n    }\r\n  }\r\n\r\n  clearFilters() {\r\n    this.currentFilters = {};\r\n    this.filteredData = [...this.originalData];\r\n    \r\n    // Reset pagination to first page\r\n    if (this.table.paginationManager) {\r\n      this.table.paginationManager.resetToFirstPage();\r\n    }\r\n  }\r\n\r\n  clearSorting() {\r\n    this.currentSorts = [];\r\n    // Don't change the filtered data order, just clear the sort state\r\n    \r\n    if (this.table.paginationManager) {\r\n      this.table.paginationManager.resetToFirstPage();\r\n    }\r\n  }\r\n\r\n  // Legacy method for backward compatibility\r\n  getPageData(page = 1) {\r\n    const pageSize = this.table.paginationManager ? \r\n      this.table.paginationManager.pageSize : 10;\r\n    const start = (page - 1) * pageSize;\r\n    return this.filteredData.slice(start, start + pageSize);\r\n  }\r\n}","export default class Renderer {\r\n  constructor(table) {\r\n    this.table = table;\r\n  }\r\n\r\n  renderTable(data, virtualMode = false) {\r\n    const columns = this.table.columnManager ? this.table.columnManager.getColumns() : (this.table.options.columns || []);\r\n    const controlsOptions = this.table.options.controls;\r\n    const isVirtualScrollEnabled = this.table.virtualScrollManager && this.table.virtualScrollManager.isEnabled();\r\n\r\n    // Preserve search input value and focus state before re-rendering\r\n    let preservedSearchValue = '';\r\n    let searchInputHadFocus = false;\r\n    let cursorPosition = 0;\r\n    const existingSearchInput = this.table.container.querySelector('.tablix-search-input');\r\n    if (existingSearchInput) {\r\n      preservedSearchValue = existingSearchInput.value;\r\n      searchInputHadFocus = document.activeElement === existingSearchInput;\r\n      cursorPosition = existingSearchInput.selectionStart || 0;\r\n    }\r\n\r\n    // Determine selection attributes\r\n    const selectionEnabled = this.table.selectionManager && this.table.selectionManager.options.enabled;\r\n    const selectionAttributes = selectionEnabled \r\n      ? `data-selection-enabled data-selection-mode=\"${this.table.selectionManager.options.mode}\"` \r\n      : 'data-selection-disabled';\r\n\r\n    let html = `<div class=\"tablix-wrapper\" ${selectionAttributes}>`;\r\n    \r\n    // Top controls\r\n    if (controlsOptions.enabled && (controlsOptions.position === 'top' || controlsOptions.position === 'both')) {\r\n      html += this.renderControls('top');\r\n    }\r\n    \r\n    // Virtual scroll container (if enabled)\r\n    if (isVirtualScrollEnabled) {\r\n      const containerHeight = this.table.options.virtualScroll.containerHeight || 400;\r\n      html += `<div class=\"tablix-scroll-container\" style=\"height: ${containerHeight}px; overflow: auto; position: relative; border: 1px solid #ddd;\">`;\r\n    }\r\n    \r\n    // Table\r\n    html += '<table class=\"tablix-table\" style=\"width:100%; border-collapse:collapse;\">';\r\n\r\n    // Header\r\n    html += '<thead class=\"tablix-thead\"><tr class=\"tablix-header-row\">';\r\n    columns.forEach(col => {\r\n      const isSortable = this._isColumnSortable(col);\r\n      const sortDirection = this._getSortDirection(col.name);\r\n      const sortClass = isSortable ? ' tablix-sortable' : '';\r\n      const sortDirectionClass = sortDirection ? ` tablix-sorted tablix-sorted-${sortDirection}` : '';\r\n      \r\n      html += `<th class=\"tablix-th${sortClass}${sortDirectionClass}\" data-column=\"${col.name}\">`;\r\n      html += `<div class=\"tablix-th-content\">`;\r\n      html += `<span class=\"tablix-th-text\">${col.title || col.name}</span>`;\r\n      \r\n      if (isSortable) {\r\n        html += `<span class=\"tablix-sort-indicator\">`;\r\n        if (sortDirection === 'asc') {\r\n          html += `<span class=\"tablix-sort-arrow tablix-sort-asc\" aria-label=\"Sorted ascending\">↑</span>`;\r\n        } else if (sortDirection === 'desc') {\r\n          html += `<span class=\"tablix-sort-arrow tablix-sort-desc\" aria-label=\"Sorted descending\">↓</span>`;\r\n        } else {\r\n          html += `<span class=\"tablix-sort-arrow tablix-sort-none\" aria-label=\"Not sorted\">↕</span>`;\r\n        }\r\n        html += `</span>`;\r\n      }\r\n      \r\n      html += `</div>`;\r\n      html += `</th>`;\r\n    });\r\n    html += '</tr></thead>';\r\n\r\n    // Body\r\n    html += '<tbody class=\"tablix-tbody\">';\r\n    \r\n    // For virtual scrolling, only render empty structure or limited rows\r\n    if (isVirtualScrollEnabled && virtualMode) {\r\n      // Empty body for virtual scrolling - rows will be added by VirtualScrollManager\r\n      html += `<tr class=\"tablix-placeholder-row\" style=\"display: none;\"><td colspan=\"${columns.length}\"></td></tr>`;\r\n    } else if (data.length === 0) {\r\n      html += `<tr class=\"tablix-empty-row\"><td colspan=\"${columns.length}\" class=\"tablix-empty-cell\">No data available</td></tr>`;\r\n    } else {\r\n      data.forEach((row, index) => {\r\n        // Calculate global row index for pagination\r\n        let globalIndex = index;\r\n        if (this.table.paginationManager && this.table.paginationManager.options.mode === 'client') {\r\n          const currentPage = this.table.paginationManager.currentPage;\r\n          const pageSize = this.table.paginationManager.pageSize;\r\n          globalIndex = (currentPage - 1) * pageSize + index;\r\n        }\r\n        \r\n        html += `<tr class=\"tablix-row\" data-row-index=\"${globalIndex}\">`;\r\n        columns.forEach(col => {\r\n          const cell = row[col.name];\r\n          let renderedCell;\r\n          \r\n          // Use ColumnManager for formatting if available\r\n          if (this.table.columnManager) {\r\n            const result = this.table.columnManager.formatCellValue(col.name, cell, row);\r\n            if (result.isHtml) {\r\n              // Custom renderer returned HTML - use as is\r\n              renderedCell = result.value;\r\n            } else {\r\n              // Formatted or raw value - escape for safety\r\n              renderedCell = this.escapeHtml(result.value);\r\n            }\r\n          } else {\r\n            // Fallback to original renderer logic\r\n            renderedCell = col.renderer ? col.renderer(cell, row) : this.escapeHtml(cell);\r\n          }\r\n          \r\n          html += `<td class=\"tablix-td\">${renderedCell}</td>`;\r\n        });\r\n        html += '</tr>';\r\n      });\r\n    }\r\n    html += '</tbody>';\r\n    html += '</table>';\r\n    \r\n    // Close virtual scroll container if enabled\r\n    if (isVirtualScrollEnabled) {\r\n      html += '</div>'; // Close tablix-scroll-container\r\n    }\r\n\r\n    // Pagination will be rendered separately\r\n    html += '<div class=\"tablix-pagination-container\"></div>';\r\n    \r\n    // Bottom controls\r\n    if (controlsOptions.enabled && (controlsOptions.position === 'bottom' || controlsOptions.position === 'both')) {\r\n      html += this.renderControls('bottom');\r\n    }\r\n    \r\n    html += '</div>';\r\n\r\n    // Update DOM\r\n    this.table.container.innerHTML = html;\r\n    \r\n    // Restore search input value immediately after DOM update\r\n    if (preservedSearchValue) {\r\n      const newSearchInput = this.table.container.querySelector('.tablix-search-input');\r\n      if (newSearchInput) {\r\n        newSearchInput.value = preservedSearchValue;\r\n      }\r\n    }\r\n    \r\n    // Render pagination controls if pagination is enabled\r\n    this.renderPagination();\r\n    \r\n    // Bind control events\r\n    if (controlsOptions.enabled) {\r\n      this.bindControlEvents();\r\n    }\r\n\r\n    // Bind search events if search is enabled\r\n    if (this.table.searchManager) {\r\n      this.table.searchManager.bindEvents();\r\n    }\r\n\r\n    // Bind sort events if sorting is enabled\r\n    if (this.table.sortingManager) {\r\n      this.bindSortEvents();\r\n    }\r\n\r\n    // Bind row click events if selection is enabled\r\n    if (this.table.selectionManager && this.table.selectionManager.options.enabled) {\r\n      this.bindRowClickEvents();\r\n    }\r\n\r\n    // Render filter icons and bind events if filtering is enabled\r\n    if (this.table.filterUI) {\r\n      this.table.filterUI.renderFilterIcons();\r\n    }\r\n\r\n    // Restore focus AFTER all event binding is complete\r\n    if (searchInputHadFocus) {\r\n      const newSearchInput = this.table.container.querySelector('.tablix-search-input');\r\n      if (newSearchInput) {\r\n        // Use requestAnimationFrame to ensure focus happens after all DOM operations\r\n        requestAnimationFrame(() => {\r\n          newSearchInput.focus();\r\n          // Restore cursor position\r\n          if (cursorPosition > 0) {\r\n            newSearchInput.setSelectionRange(cursorPosition, cursorPosition);\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    // Trigger afterRender event\r\n    this.table.eventManager.trigger('afterRender');\r\n  }\r\n\r\n  renderPagination() {\r\n    const paginationContainer = this.table.container.querySelector('.tablix-pagination-container');\r\n    if (!paginationContainer || !this.table.paginationManager) {\r\n      return;\r\n    }\r\n\r\n    const paginationManager = this.table.paginationManager;\r\n    const info = paginationManager.getInfo();\r\n    \r\n    if (!paginationManager.options.enabled && paginationManager.options.enabled !== undefined) {\r\n      paginationContainer.innerHTML = '';\r\n      return;\r\n    }\r\n\r\n    // Don't show pagination if there's only one page and no custom page sizes\r\n    if (info.totalPages <= 1 && !paginationManager.options.showPageSizes) {\r\n      paginationContainer.innerHTML = '';\r\n      return;\r\n    }\r\n\r\n    let html = '<div class=\"tablix-pagination\">';\r\n    \r\n    // Page info\r\n    html += `<div class=\"tablix-pagination-info\">`;\r\n    if (info.totalRows === 0) {\r\n      html += 'No records found';\r\n    } else {\r\n      html += `Showing ${info.startRow}-${info.endRow} of ${info.totalRows} records`;\r\n    }\r\n    html += '</div>';\r\n\r\n    // Page size selector\r\n    if (paginationManager.options.showPageSizes && paginationManager.options.pageSizeOptions.length > 1) {\r\n      html += '<div class=\"tablix-pagination-page-size\">';\r\n      html += 'Show ';\r\n      html += '<select class=\"tablix-page-size-select\">';\r\n      paginationManager.options.pageSizeOptions.forEach(size => {\r\n        const selected = size === info.pageSize ? ' selected' : '';\r\n        html += `<option value=\"${size}\"${selected}>${size}</option>`;\r\n      });\r\n      html += '</select>';\r\n      html += ' records per page';\r\n      html += '</div>';\r\n    }\r\n\r\n    // Navigation controls\r\n    if (info.totalPages > 1) {\r\n      html += '<div class=\"tablix-pagination-nav\">';\r\n      \r\n      // First page\r\n      if (paginationManager.options.showFirstLast) {\r\n        const disabled = info.currentPage === 1 ? ' disabled' : '';\r\n        html += `<button class=\"tablix-pagination-btn tablix-pagination-first\" data-page=\"1\"${disabled}>First</button>`;\r\n      }\r\n      \r\n      // Previous page\r\n      if (paginationManager.options.showPrevNext) {\r\n        const disabled = !info.hasPrevPage ? ' disabled' : '';\r\n        html += `<button class=\"tablix-pagination-btn tablix-pagination-prev\" data-page=\"${info.currentPage - 1}\"${disabled}>Previous</button>`;\r\n      }\r\n      \r\n      // Page numbers\r\n      if (paginationManager.options.showPageNumbers) {\r\n        const pageNumbers = paginationManager.getPageNumbers();\r\n        pageNumbers.forEach(page => {\r\n          if (page === '...') {\r\n            html += '<span class=\"tablix-pagination-ellipsis\">...</span>';\r\n          } else {\r\n            const active = page === info.currentPage ? ' active' : '';\r\n            html += `<button class=\"tablix-pagination-btn tablix-pagination-page${active}\" data-page=\"${page}\">${page}</button>`;\r\n          }\r\n        });\r\n      }\r\n      \r\n      // Next page\r\n      if (paginationManager.options.showPrevNext) {\r\n        const disabled = !info.hasNextPage ? ' disabled' : '';\r\n        html += `<button class=\"tablix-pagination-btn tablix-pagination-next\" data-page=\"${info.currentPage + 1}\"${disabled}>Next</button>`;\r\n      }\r\n      \r\n      // Last page\r\n      if (paginationManager.options.showFirstLast) {\r\n        const disabled = info.currentPage === info.totalPages ? ' disabled' : '';\r\n        html += `<button class=\"tablix-pagination-btn tablix-pagination-last\" data-page=\"${info.totalPages}\"${disabled}>Last</button>`;\r\n      }\r\n      \r\n      html += '</div>';\r\n    }\r\n\r\n    // Loading indicator\r\n    if (info.isLoading) {\r\n      html += '<div class=\"tablix-pagination-loading\">Loading...</div>';\r\n    }\r\n    \r\n    html += '</div>';\r\n\r\n    paginationContainer.innerHTML = html;\r\n    this.bindPaginationEvents();\r\n  }\r\n\r\n  bindPaginationEvents() {\r\n    const paginationContainer = this.table.container.querySelector('.tablix-pagination');\r\n    if (!paginationContainer) {\r\n      return;\r\n    }\r\n\r\n    // Page navigation buttons\r\n    paginationContainer.addEventListener('click', async (e) => {\r\n      if (e.target.classList.contains('tablix-pagination-btn') && !e.target.disabled) {\r\n        e.preventDefault();\r\n        const page = parseInt(e.target.dataset.page);\r\n        if (!isNaN(page)) {\r\n          try {\r\n            await this.table.paginationManager.goToPage(page);\r\n          } catch (error) {\r\n            console.error('Failed to navigate to page:', error);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Page size selector\r\n    const pageSizeSelect = paginationContainer.querySelector('.tablix-page-size-select');\r\n    if (pageSizeSelect) {\r\n      pageSizeSelect.addEventListener('change', async (e) => {\r\n        try {\r\n          const newPageSize = parseInt(e.target.value);\r\n          await this.table.paginationManager.changePageSize(newPageSize);\r\n        } catch (error) {\r\n          console.error('Failed to change page size:', error);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Escape HTML to prevent XSS attacks\r\n   */\r\n  escapeHtml(text) {\r\n    if (text == null) return '';\r\n    const div = document.createElement('div');\r\n    div.textContent = text.toString();\r\n    return div.innerHTML;\r\n  }\r\n\r\n  /**\r\n   * Render loading state\r\n   */\r\n  renderLoading() {\r\n    this.table.container.innerHTML = '<div class=\"tablix-loading\">Loading...</div>';\r\n  }\r\n\r\n  /**\r\n   * Render error state\r\n   */\r\n  renderError(error) {\r\n    this.table.container.innerHTML = `<div class=\"tablix-error\">Error: ${this.escapeHtml(error.message || error)}</div>`;\r\n  }\r\n\r\n  /**\r\n   * Render control panel\r\n   */\r\n  renderControls(position) {\r\n    const controlsOptions = this.table.options.controls;\r\n    const searchOptions = this.table.options.search || { enabled: false, placeholder: 'Search...' };\r\n    \r\n    let html = `<div class=\"tablix-controls tablix-controls-${position}\">`;\r\n    \r\n    // Left side controls\r\n    html += '<div class=\"tablix-controls-left\">';\r\n    \r\n    // Pagination controls\r\n    if (controlsOptions.pagination && this.table.paginationManager) {\r\n      html += '<div class=\"tablix-control-group tablix-pagination-controls\">';\r\n      html += '<button type=\"button\" class=\"tablix-btn tablix-control-btn\" data-action=\"firstPage\">First</button>';\r\n      html += '<button type=\"button\" class=\"tablix-btn tablix-control-btn\" data-action=\"prevPage\">Previous</button>';\r\n      html += '<button type=\"button\" class=\"tablix-btn tablix-control-btn\" data-action=\"nextPage\">Next</button>';\r\n      html += '<button type=\"button\" class=\"tablix-btn tablix-control-btn\" data-action=\"lastPage\">Last</button>';\r\n      html += '</div>';\r\n    }\r\n    \r\n    // Page size control\r\n    if (controlsOptions.pageSize && this.table.paginationManager) {\r\n      const pageSizeOptions = this.table.paginationManager.options.pageSizeOptions;\r\n      const currentPageSize = this.table.paginationManager.pageSize;\r\n      \r\n      html += '<div class=\"tablix-control-group tablix-page-size-group\">';\r\n      html += '<label for=\"tablix-page-size-select\">Show:</label>';\r\n      html += '<select class=\"tablix-page-size-select\" id=\"tablix-page-size-select\">';\r\n      pageSizeOptions.forEach(size => {\r\n        const selected = size === currentPageSize ? ' selected' : '';\r\n        html += `<option value=\"${size}\"${selected}>${size}</option>`;\r\n      });\r\n      html += '</select>';\r\n      html += '<span>entries</span>';\r\n      html += '</div>';\r\n    }\r\n    \r\n    // Refresh control\r\n    if (controlsOptions.refresh) {\r\n      html += '<div class=\"tablix-control-group tablix-refresh-group\">';\r\n      html += '<button type=\"button\" class=\"tablix-btn tablix-control-btn\" data-action=\"refresh\" title=\"Refresh data\">⟳</button>';\r\n      html += '</div>';\r\n    }\r\n    \r\n    html += '</div>'; // Close left controls\r\n    \r\n    // Right side controls\r\n    html += '<div class=\"tablix-controls-right\">';\r\n    \r\n    // Search control\r\n    if (controlsOptions.search && searchOptions.enabled) {\r\n      // Ensure placeholder always has a default value to prevent \"undefined\" display\r\n      const placeholderText = searchOptions.placeholder || 'Search...';\r\n      \r\n      html += '<div class=\"tablix-control-group tablix-search-group\">';\r\n      html += `<input type=\"text\" \r\n                      class=\"tablix-search-input\" \r\n                      id=\"tablix-search-input\" \r\n                      name=\"table-search\"\r\n                      placeholder=\"${placeholderText}\" />`;\r\n      html += '<button type=\"button\" class=\"tablix-btn tablix-search-clear\" title=\"Clear search\" style=\"display: none;\">✕</button>';\r\n      html += '</div>';\r\n    }\r\n    \r\n    html += '</div>'; // Close right controls\r\n    \r\n    html += '</div>'; // Close main controls container\r\n    \r\n    return html;\r\n  }\r\n\r\n  /**\r\n   * Bind control panel events\r\n   */\r\n  bindControlEvents() {\r\n    const wrapper = this.table.container.querySelector('.tablix-wrapper');\r\n    if (!wrapper) return;\r\n\r\n    // Page size selector\r\n    const pageSizeSelect = wrapper.querySelector('.tablix-page-size-select');\r\n    if (pageSizeSelect) {\r\n      pageSizeSelect.addEventListener('change', async (e) => {\r\n        try {\r\n          const newPageSize = parseInt(e.target.value);\r\n          await this.table.changePageSize(newPageSize);\r\n        } catch (error) {\r\n          console.error('Failed to change page size:', error);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Control buttons\r\n    wrapper.addEventListener('click', async (e) => {\r\n      if (e.target.classList.contains('tablix-control-btn')) {\r\n        e.preventDefault();\r\n        const action = e.target.dataset.action;\r\n        \r\n        try {\r\n          switch (action) {\r\n            case 'firstPage':\r\n              await this.table.firstPage();\r\n              break;\r\n            case 'prevPage':\r\n              await this.table.prevPage();\r\n              break;\r\n            case 'nextPage':\r\n              await this.table.nextPage();\r\n              break;\r\n            case 'lastPage':\r\n              await this.table.lastPage();\r\n              break;\r\n            case 'refresh':\r\n              await this.handleRefresh();\r\n              break;\r\n            case 'export':\r\n              this.handleExport();\r\n              break;\r\n          }\r\n        } catch (error) {\r\n          console.error(`Failed to execute action ${action}:`, error);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle refresh functionality\r\n   */\r\n  async handleRefresh() {\r\n    this.table.eventManager.trigger('beforeRefresh');\r\n    \r\n    if (this.table.options.onRefresh && typeof this.table.options.onRefresh === 'function') {\r\n      // Custom refresh handler\r\n      try {\r\n        const newData = await this.table.options.onRefresh();\r\n        if (newData) {\r\n          await this.table.loadData(newData);\r\n        }\r\n      } catch (error) {\r\n        console.error('Custom refresh failed:', error);\r\n      }\r\n    } else if (this.table.paginationManager && this.table.paginationManager.options.mode === 'server') {\r\n      // Server-side refresh\r\n      await this.table.paginationManager.refreshTable();\r\n    } else {\r\n      // Client-side refresh - just re-render current data\r\n      await this.table.refreshTable();\r\n    }\r\n    \r\n    this.table.eventManager.trigger('afterRefresh');\r\n  }\r\n\r\n  /**\r\n   * Handle export functionality\r\n   */\r\n  handleExport() {\r\n    const data = this.table.getData();\r\n    const columns = this.table.options.columns || [];\r\n    \r\n    // Simple CSV export\r\n    let csv = columns.map(col => col.title || col.name).join(',') + '\\n';\r\n    \r\n    data.forEach(row => {\r\n      const values = columns.map(col => {\r\n        const value = row[col.name];\r\n        // Simple CSV escaping\r\n        return typeof value === 'string' && value.includes(',') \r\n          ? `\"${value.replace(/\"/g, '\"\"')}\"` \r\n          : value;\r\n      });\r\n      csv += values.join(',') + '\\n';\r\n    });\r\n    \r\n    // Download CSV\r\n    const blob = new Blob([csv], { type: 'text/csv' });\r\n    const url = URL.createObjectURL(blob);\r\n    const a = document.createElement('a');\r\n    a.href = url;\r\n    a.download = 'table-data.csv';\r\n    document.body.appendChild(a);\r\n    a.click();\r\n    document.body.removeChild(a);\r\n    URL.revokeObjectURL(url);\r\n    \r\n    this.table.eventManager.trigger('afterExport', { data, format: 'csv' });\r\n  }\r\n\r\n  /**\r\n   * Bind sorting events to header columns\r\n   */\r\n  bindSortEvents() {\r\n    const headerRow = this.table.container.querySelector('.tablix-header-row');\r\n    if (!headerRow) return;\r\n\r\n    headerRow.addEventListener('click', async (e) => {\r\n      const th = e.target.closest('.tablix-sortable');\r\n      if (!th) return;\r\n\r\n      e.preventDefault();\r\n      \r\n      const columnName = th.dataset.column;\r\n      \r\n      try {\r\n        await this.table.toggleSort(columnName);\r\n      } catch (error) {\r\n        console.error('Failed to sort column:', error);\r\n      }\r\n    });\r\n\r\n    // Keyboard support for accessibility\r\n    headerRow.addEventListener('keydown', async (e) => {\r\n      const th = e.target.closest('.tablix-sortable');\r\n      if (!th || (e.key !== 'Enter' && e.key !== ' ')) return;\r\n\r\n      e.preventDefault();\r\n      \r\n      const columnName = th.dataset.column;\r\n      \r\n      try {\r\n        await this.table.toggleSort(columnName);\r\n      } catch (error) {\r\n        console.error('Failed to sort column:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Bind row click events for selection\r\n   */\r\n  bindRowClickEvents() {\r\n    const tbody = this.table.container.querySelector('.tablix-tbody');\r\n    if (!tbody) return;\r\n\r\n    tbody.addEventListener('click', (e) => {\r\n      const row = e.target.closest('.tablix-row');\r\n      if (!row || row.classList.contains('tablix-empty-row')) return;\r\n\r\n      const globalRowIndex = parseInt(row.dataset.rowIndex, 10);\r\n      if (isNaN(globalRowIndex)) return;\r\n\r\n      // Convert global index to local index for current page data\r\n      let localRowIndex = globalRowIndex;\r\n      if (this.table.paginationManager && this.table.paginationManager.options.mode === 'client') {\r\n        const currentPage = this.table.paginationManager.currentPage;\r\n        const pageSize = this.table.paginationManager.pageSize;\r\n        localRowIndex = globalRowIndex - (currentPage - 1) * pageSize;\r\n      }\r\n\r\n      // Get current page data to find the clicked row\r\n      const currentData = this.getCurrentPageData();\r\n      if (localRowIndex >= 0 && localRowIndex < currentData.length) {\r\n        const rowData = currentData[localRowIndex];\r\n        \r\n        // Trigger row click event for SelectionManager with global index\r\n        this.table.eventManager.trigger('rowClick', {\r\n          rowData,\r\n          rowIndex: globalRowIndex, // Pass global index\r\n          localRowIndex: localRowIndex, // Also pass local index if needed\r\n          originalEvent: e\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get current page data (same logic as SelectionManager)\r\n   */\r\n  getCurrentPageData() {\r\n    if (this.table.paginationManager) {\r\n      return this.table.paginationManager.getCurrentPageData() || [];\r\n    }\r\n    return this.table.dataManager.getData();\r\n  }\r\n\r\n  /**\r\n   * Update sort indicators in headers\r\n   */\r\n  updateSortIndicators(currentSort) {\r\n    const headers = this.table.container.querySelectorAll('.tablix-th[data-column]');\r\n    \r\n    headers.forEach(th => {\r\n      const columnName = th.dataset.column;\r\n      const isSorted = currentSort && currentSort.column === columnName;\r\n      \r\n      // Remove all sort classes\r\n      th.classList.remove('tablix-sorted', 'tablix-sorted-asc', 'tablix-sorted-desc');\r\n      \r\n      const indicator = th.querySelector('.tablix-sort-indicator');\r\n      if (!indicator) return;\r\n\r\n      const arrow = indicator.querySelector('.tablix-sort-arrow');\r\n      if (!arrow) return;\r\n\r\n      if (isSorted) {\r\n        // Column is sorted\r\n        th.classList.add('tablix-sorted', `tablix-sorted-${currentSort.direction}`);\r\n        arrow.classList.remove('tablix-sort-none', 'tablix-sort-asc', 'tablix-sort-desc');\r\n        arrow.classList.add(`tablix-sort-${currentSort.direction}`);\r\n        arrow.textContent = currentSort.direction === 'asc' ? '↑' : '↓';\r\n        arrow.setAttribute('aria-label', `Sorted ${currentSort.direction === 'asc' ? 'ascending' : 'descending'}`);\r\n        arrow.removeAttribute('data-sort-order');\r\n      } else {\r\n        // Column is not sorted\r\n        arrow.classList.remove('tablix-sort-asc', 'tablix-sort-desc');\r\n        arrow.classList.add('tablix-sort-none');\r\n        arrow.textContent = '↕';\r\n        arrow.setAttribute('aria-label', 'Not sorted');\r\n        arrow.removeAttribute('data-sort-order');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if a column is sortable\r\n   */\r\n  _isColumnSortable(column) {\r\n    if (!this.table.sortingManager) return false;\r\n    return this.table.sortingManager.isColumnSortable(column.name);\r\n  }\r\n\r\n  /**\r\n   * Get sort direction for a column\r\n   */\r\n  _getSortDirection(columnName) {\r\n    if (!this.table.sortingManager) return null;\r\n    return this.table.sortingManager.getSortDirection(columnName);\r\n  }\r\n}","export default class EventManager {\r\n  constructor() {\r\n    this.events = {};\r\n  }\r\n\r\n  on(event, callback) {\r\n    if (!this.events[event]) this.events[event] = [];\r\n    this.events[event].push(callback);\r\n  }\r\n\r\n  off(event, callback) {\r\n    if (this.events[event]) {\r\n      const index = this.events[event].indexOf(callback);\r\n      if (index > -1) {\r\n        this.events[event].splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  clear(event) {\r\n    if (event) {\r\n      this.events[event] = [];\r\n    } else {\r\n      this.events = {};\r\n    }\r\n  }\r\n\r\n  trigger(event, payload) {\r\n    (this.events[event] || []).forEach(cb => cb(payload));\r\n  }\r\n}","/**\r\n * PaginationManager handles both client-side and server-side pagination\r\n * \r\n * Features:\r\n * - Client-side: slices filtered data locally\r\n * - Server-side: calls async data loader with pagination params\r\n * - Consistent API regardless of pagination mode\r\n * - Event emission for page changes\r\n * - Customizable pagination controls\r\n */\r\nexport default class PaginationManager {\r\n  constructor(table, options = {}) {\r\n    this.table = table;\r\n    this.options = {\r\n      pageSize: 10,\r\n      mode: 'client', // 'client' or 'server'\r\n      showPageNumbers: true,\r\n      maxPageNumbers: 5,\r\n      showFirstLast: true,\r\n      showPrevNext: true,\r\n      showPageSizes: false,\r\n      pageSizeOptions: [10, 25, 50, 100],\r\n      serverDataLoader: null, // async function for server-side pagination\r\n      ...options\r\n    };\r\n\r\n    // Pagination state\r\n    this.currentPage = 1;\r\n    this.totalPages = 1;\r\n    this.totalRows = 0;\r\n    this.pageSize = this.options.pageSize;\r\n    this.isLoading = false;\r\n\r\n    // Event bindings\r\n    this.init();\r\n  }\r\n\r\n  init() {\r\n    this.updatePaginationInfo();\r\n  }\r\n\r\n  /**\r\n   * Update pagination information based on current data\r\n   */\r\n  updatePaginationInfo(totalRows = null) {\r\n    if (this.options.mode === 'client') {\r\n      // For client-side pagination, calculate from filtered data\r\n      this.totalRows = this.table.dataManager.filteredData.length;\r\n    } else {\r\n      // For server-side pagination, total rows should be provided\r\n      this.totalRows = totalRows || this.totalRows;\r\n    }\r\n\r\n    this.totalPages = Math.ceil(this.totalRows / this.pageSize) || 1;\r\n    \r\n    // Ensure current page is within bounds\r\n    if (this.currentPage > this.totalPages) {\r\n      this.currentPage = this.totalPages;\r\n    }\r\n    if (this.currentPage < 1) {\r\n      this.currentPage = 1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current page data\r\n   * For client-side: slice the filtered data\r\n   * For server-side: return cached data or trigger load\r\n   */\r\n  async getPageData() {\r\n    if (this.options.mode === 'client') {\r\n      return this.getClientPageData();\r\n    } else {\r\n      return await this.getServerPageData();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get page data for client-side pagination\r\n   */\r\n  getClientPageData() {\r\n    const start = (this.currentPage - 1) * this.pageSize;\r\n    const end = start + this.pageSize;\r\n    return this.table.dataManager.filteredData.slice(start, end);\r\n  }\r\n\r\n  /**\r\n   * Get current page data synchronously (for selection and other features)\r\n   * Returns the data that is currently displayed on the page\r\n   */\r\n  getCurrentPageData() {\r\n    if (this.options.mode === 'client') {\r\n      return this.getClientPageData();\r\n    } else {\r\n      // For server-side pagination, return the currently cached data\r\n      // This assumes the data has already been loaded by a previous getPageData call\r\n      return this.table.dataManager.getData();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get page data for server-side pagination\r\n   */\r\n  async getServerPageData() {\r\n    if (!this.options.serverDataLoader) {\r\n      throw new Error('Server data loader not configured for server-side pagination');\r\n    }\r\n\r\n    this.isLoading = true;\r\n    this.table.eventManager.trigger('beforePageLoad', {\r\n      page: this.currentPage,\r\n      pageSize: this.pageSize\r\n    });\r\n\r\n    try {\r\n      const result = await this.options.serverDataLoader({\r\n        page: this.currentPage,\r\n        pageSize: this.pageSize,\r\n        // Include current filter/sort state if available\r\n        filters: this.table.dataManager.currentFilters || {},\r\n        sorts: this.table.dataManager.currentSorts || []\r\n      });\r\n\r\n      // Expect result to have: { data: [], totalRows: number }\r\n      if (result.totalRows !== undefined) {\r\n        this.updatePaginationInfo(result.totalRows);\r\n      }\r\n\r\n      this.isLoading = false;\r\n      this.table.eventManager.trigger('afterPageLoad', {\r\n        page: this.currentPage,\r\n        pageSize: this.pageSize,\r\n        data: result.data,\r\n        totalRows: result.totalRows\r\n      });\r\n\r\n      return result.data;\r\n    } catch (error) {\r\n      this.isLoading = false;\r\n      this.table.eventManager.trigger('pageLoadError', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Navigate to specific page\r\n   */\r\n  async goToPage(pageNumber) {\r\n    const targetPage = Math.max(1, Math.min(pageNumber, this.totalPages));\r\n    \r\n    if (targetPage === this.currentPage) {\r\n      return;\r\n    }\r\n\r\n    const oldPage = this.currentPage;\r\n    this.currentPage = targetPage;\r\n\r\n    this.table.eventManager.trigger('beforePageChange', {\r\n      oldPage,\r\n      newPage: this.currentPage,\r\n      pageSize: this.pageSize\r\n    });\r\n\r\n    try {\r\n      await this.refreshTable();\r\n      \r\n      this.table.eventManager.trigger('afterPageChange', {\r\n        oldPage,\r\n        newPage: this.currentPage,\r\n        pageSize: this.pageSize\r\n      });\r\n    } catch (error) {\r\n      // Revert page change on error\r\n      this.currentPage = oldPage;\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Go to next page\r\n   */\r\n  async nextPage() {\r\n    if (this.currentPage < this.totalPages) {\r\n      await this.goToPage(this.currentPage + 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Go to previous page\r\n   */\r\n  async prevPage() {\r\n    if (this.currentPage > 1) {\r\n      await this.goToPage(this.currentPage - 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Go to first page\r\n   */\r\n  async firstPage() {\r\n    await this.goToPage(1);\r\n  }\r\n\r\n  /**\r\n   * Go to last page\r\n   */\r\n  async lastPage() {\r\n    await this.goToPage(this.totalPages);\r\n  }\r\n\r\n  /**\r\n   * Change page size\r\n   */\r\n  async changePageSize(newPageSize) {\r\n    if (newPageSize === this.pageSize) {\r\n      return;\r\n    }\r\n\r\n    const oldPageSize = this.pageSize;\r\n    this.pageSize = newPageSize;\r\n\r\n    // Try to maintain current position in the dataset\r\n    const currentRow = (this.currentPage - 1) * oldPageSize;\r\n    const newPage = Math.floor(currentRow / newPageSize) + 1;\r\n\r\n    this.updatePaginationInfo();\r\n    \r\n    this.table.eventManager.trigger('beforePageSizeChange', {\r\n      oldPageSize,\r\n      newPageSize: this.pageSize,\r\n      oldPage: this.currentPage,\r\n      newPage\r\n    });\r\n\r\n    this.currentPage = newPage;\r\n    await this.refreshTable();\r\n\r\n    this.table.eventManager.trigger('afterPageSizeChange', {\r\n      oldPageSize,\r\n      newPageSize: this.pageSize,\r\n      page: this.currentPage\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Refresh the table with current pagination settings\r\n   */\r\n  async refreshTable() {\r\n    const pageData = await this.getPageData();\r\n    this.table.renderer.renderTable(pageData);\r\n    this.table.renderer.renderPagination();\r\n  }\r\n\r\n  /**\r\n   * Reset pagination to first page (useful after filtering/sorting)\r\n   */\r\n  async resetToFirstPage() {\r\n    this.currentPage = 1;\r\n    this.updatePaginationInfo();\r\n    await this.refreshTable();\r\n  }\r\n\r\n  /**\r\n   * Get pagination state info\r\n   */\r\n  getInfo() {\r\n    const start = this.totalRows === 0 ? 0 : (this.currentPage - 1) * this.pageSize + 1;\r\n    const end = Math.min(this.currentPage * this.pageSize, this.totalRows);\r\n\r\n    return {\r\n      currentPage: this.currentPage,\r\n      totalPages: this.totalPages,\r\n      pageSize: this.pageSize,\r\n      totalRows: this.totalRows,\r\n      startRow: start,\r\n      endRow: end,\r\n      hasNextPage: this.currentPage < this.totalPages,\r\n      hasPrevPage: this.currentPage > 1,\r\n      isLoading: this.isLoading\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get page numbers to display in pagination controls\r\n   */\r\n  getPageNumbers() {\r\n    const maxPages = this.options.maxPageNumbers;\r\n    const pages = [];\r\n\r\n    if (this.totalPages <= maxPages) {\r\n      // Show all pages\r\n      for (let i = 1; i <= this.totalPages; i++) {\r\n        pages.push(i);\r\n      }\r\n    } else {\r\n      // Show truncated page numbers\r\n      const half = Math.floor(maxPages / 2);\r\n      let start = Math.max(1, this.currentPage - half);\r\n      let end = Math.min(this.totalPages, start + maxPages - 1);\r\n\r\n      // Adjust if we're near the end\r\n      if (end - start + 1 < maxPages) {\r\n        start = Math.max(1, end - maxPages + 1);\r\n      }\r\n\r\n      for (let i = start; i <= end; i++) {\r\n        pages.push(i);\r\n      }\r\n\r\n      // Add ellipsis indicators\r\n      if (start > 1) {\r\n        if (start > 2) pages.unshift('...');\r\n        pages.unshift(1);\r\n      }\r\n      if (end < this.totalPages) {\r\n        if (end < this.totalPages - 1) pages.push('...');\r\n        pages.push(this.totalPages);\r\n      }\r\n    }\r\n\r\n    return pages;\r\n  }\r\n\r\n  /**\r\n   * Enable/disable pagination\r\n   */\r\n  setEnabled(enabled) {\r\n    this.options.enabled = enabled;\r\n    this.table.renderer.renderPagination();\r\n  }\r\n\r\n  /**\r\n   * Switch between client and server mode\r\n   */\r\n  async setMode(mode, serverDataLoader = null) {\r\n    if (mode === this.options.mode) {\r\n      return;\r\n    }\r\n\r\n    this.options.mode = mode;\r\n    if (mode === 'server' && serverDataLoader) {\r\n      this.options.serverDataLoader = serverDataLoader;\r\n    }\r\n\r\n    // Reset to first page when switching modes\r\n    this.currentPage = 1;\r\n    this.updatePaginationInfo();\r\n    await this.refreshTable();\r\n  }\r\n}\r\n","/**\r\n * SortingManager - Handles all sorting functionality for TablixJS\r\n * Supports client-side and server-side sorting with custom sort functions\r\n */\r\nexport default class SortingManager {\r\n  constructor(table, options = {}) {\r\n    this.table = table;\r\n    this.options = {\r\n      enabled: true,\r\n      mode: 'client', // 'client' or 'server'\r\n      serverSortLoader: null, // Function to load data from server with sorting\r\n      defaultSortType: 'auto', // 'auto', 'string', 'number', 'date'\r\n      caseSensitive: false,\r\n      nullsFirst: false,\r\n      ...options\r\n    };\r\n\r\n    // Current sort state - single column only\r\n    this.currentSort = null; // { column: 'name', direction: 'asc' }\r\n    this.sortOrder = ['asc', 'desc', null]; // Click cycle order\r\n\r\n    // Predefined sort types\r\n    this.sortTypes = {\r\n      auto: this._autoSort.bind(this),\r\n      string: this._stringSort.bind(this),\r\n      number: this._numberSort.bind(this),\r\n      date: this._dateSort.bind(this),\r\n      boolean: this._booleanSort.bind(this)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Sort by a column\r\n   * @param {string} columnName - Column to sort by\r\n   * @param {string|null} direction - 'asc', 'desc', or null (unsorted)\r\n   */\r\n  async sort(columnName, direction = 'asc') {\r\n    // Trigger beforeSort event\r\n    const beforeSortData = { columnName, direction, currentSort: this.currentSort };\r\n    this.table.eventManager.trigger('beforeSort', beforeSortData);\r\n\r\n    if (this.options.mode === 'server') {\r\n      await this._sortServer(columnName, direction);\r\n    } else {\r\n      this._sortClient(columnName, direction);\r\n    }\r\n\r\n    // Update UI\r\n    this.table.renderer.updateSortIndicators(this.currentSort);\r\n    \r\n    // Refresh table display\r\n    await this.table.refreshTable();\r\n\r\n    // Trigger afterSort event\r\n    this.table.eventManager.trigger('afterSort', {\r\n      columnName,\r\n      direction,\r\n      currentSort: this.currentSort\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Toggle sort for a column (handles click cycling)\r\n   */\r\n  async toggleSort(columnName) {\r\n    const currentDirection = this.currentSort && this.currentSort.column === columnName \r\n      ? this.currentSort.direction \r\n      : null;\r\n    \r\n    // Get next direction in cycle\r\n    const currentIndex = this.sortOrder.indexOf(currentDirection);\r\n    const nextDirection = this.sortOrder[(currentIndex + 1) % this.sortOrder.length];\r\n    \r\n    await this.sort(columnName, nextDirection);\r\n  }\r\n\r\n  /**\r\n   * Client-side sorting\r\n   */\r\n  _sortClient(columnName, direction) {\r\n    // Set current sort\r\n    if (direction !== null) {\r\n      this.currentSort = { column: columnName, direction };\r\n    } else {\r\n      this.currentSort = null;\r\n    }\r\n\r\n    // Apply sorting to data\r\n    this._applySorting();\r\n  }\r\n\r\n  /**\r\n   * Server-side sorting\r\n   */\r\n  async _sortServer(columnName, direction) {\r\n    if (!this.options.serverSortLoader) {\r\n      console.warn('Server-side sorting enabled but no serverSortLoader provided');\r\n      return;\r\n    }\r\n\r\n    // Set current sort\r\n    if (direction !== null) {\r\n      this.currentSort = { column: columnName, direction };\r\n    } else {\r\n      this.currentSort = null;\r\n    }\r\n\r\n    try {\r\n      // Load data from server with current sort state\r\n      const result = await this.options.serverSortLoader({\r\n        sort: this.currentSort,\r\n        filters: this.table.dataManager.currentFilters,\r\n        page: this.table.paginationManager ? this.table.paginationManager.currentPage : 1,\r\n        pageSize: this.table.paginationManager ? this.table.paginationManager.pageSize : 10\r\n      });\r\n\r\n      // Update data manager with new data\r\n      this.table.dataManager.setServerData(result.data, result.totalRows);\r\n      \r\n    } catch (error) {\r\n      console.error('Failed to load sorted data from server:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply current sort to filtered data\r\n   */\r\n  _applySorting() {\r\n    if (!this.currentSort) return;\r\n    \r\n    const columns = this.table.options.columns || [];\r\n    \r\n    this.table.dataManager.filteredData.sort((a, b) => {\r\n      // Support both 'name' and 'key' properties for column identification\r\n      const column = columns.find(col => (col.name === this.currentSort.column) || (col.key === this.currentSort.column));\r\n      const comparison = this._compareValues(\r\n        a[this.currentSort.column], \r\n        b[this.currentSort.column], \r\n        column\r\n      );\r\n      \r\n      return this.currentSort.direction === 'desc' ? -comparison : comparison;\r\n    });\r\n\r\n    // Reset pagination to first page after sorting\r\n    if (this.table.paginationManager) {\r\n      this.table.paginationManager.resetToFirstPage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compare two values based on column configuration\r\n   */\r\n  _compareValues(a, b, column) {\r\n    // Handle null/undefined values\r\n    if (a == null && b == null) return 0;\r\n    if (a == null) return this.options.nullsFirst ? -1 : 1;\r\n    if (b == null) return this.options.nullsFirst ? 1 : -1;\r\n\r\n    // Use custom sort function if provided\r\n    if (column && column.sortFunction) {\r\n      return column.sortFunction(a, b);\r\n    }\r\n\r\n    // Use specified sort type or auto-detect\r\n    const sortType = (column && column.sortType) || this.options.defaultSortType;\r\n    \r\n    if (this.sortTypes[sortType]) {\r\n      return this.sortTypes[sortType](a, b);\r\n    }\r\n\r\n    // Fallback to auto sort\r\n    return this._autoSort(a, b);\r\n  }\r\n\r\n  /**\r\n   * Auto-detect sort type and compare\r\n   */\r\n  _autoSort(a, b) {\r\n    // Try number comparison first\r\n    const numA = parseFloat(a);\r\n    const numB = parseFloat(b);\r\n    \r\n    if (!isNaN(numA) && !isNaN(numB)) {\r\n      return numA - numB;\r\n    }\r\n\r\n    // Try date comparison - be more strict about what constitutes a date\r\n    const dateA = new Date(a);\r\n    const dateB = new Date(b);\r\n    \r\n    // More strict date validation - check if it looks like a real date format\r\n    const isDateLike = (str) => {\r\n      return /^\\d{4}-\\d{2}-\\d{2}/.test(str) || /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}/.test(str) || /^\\d{1,2}-\\d{1,2}-\\d{4}/.test(str);\r\n    };\r\n    \r\n    if (dateA.toString() !== 'Invalid Date' && dateB.toString() !== 'Invalid Date' && \r\n        isDateLike(String(a)) && isDateLike(String(b))) {\r\n      return dateA - dateB;\r\n    }\r\n\r\n    // Fall back to string comparison\r\n    return this._stringSort(a, b);\r\n  }\r\n\r\n  /**\r\n   * String comparison\r\n   */\r\n  _stringSort(a, b) {\r\n    const strA = String(a).trim();\r\n    const strB = String(b).trim();\r\n    \r\n    if (this.options.caseSensitive) {\r\n      return strA.localeCompare(strB);\r\n    }\r\n    \r\n    return strA.localeCompare(strB, undefined, { sensitivity: 'base' });\r\n  }\r\n\r\n  /**\r\n   * Number comparison\r\n   */\r\n  _numberSort(a, b) {\r\n    const numA = parseFloat(a);\r\n    const numB = parseFloat(b);\r\n    \r\n    if (isNaN(numA) && isNaN(numB)) return 0;\r\n    if (isNaN(numA)) return 1;\r\n    if (isNaN(numB)) return -1;\r\n    \r\n    return numA - numB;\r\n  }\r\n\r\n  /**\r\n   * Date comparison\r\n   */\r\n  _dateSort(a, b) {\r\n    const dateA = new Date(a);\r\n    const dateB = new Date(b);\r\n    \r\n    if (dateA.toString() === 'Invalid Date' && dateB.toString() === 'Invalid Date') return 0;\r\n    if (dateA.toString() === 'Invalid Date') return 1;\r\n    if (dateB.toString() === 'Invalid Date') return -1;\r\n    \r\n    return dateA - dateB;\r\n  }\r\n\r\n  /**\r\n   * Boolean comparison\r\n   */\r\n  _booleanSort(a, b) {\r\n    const boolA = Boolean(a);\r\n    const boolB = Boolean(b);\r\n    \r\n    if (boolA === boolB) return 0;\r\n    return boolA ? 1 : -1;\r\n  }\r\n\r\n  /**\r\n   * Clear all sorting\r\n   */  async clearSorting() {\r\n    this.currentSort = null;\r\n\r\n    if (this.options.mode === 'server') {\r\n      // Reload data without sorting\r\n      if (this.options.serverSortLoader) {\r\n        try {\r\n          const result = await this.options.serverSortLoader({\r\n            sort: null,\r\n            filters: this.table.dataManager.currentFilters,\r\n            page: this.table.paginationManager ? this.table.paginationManager.currentPage : 1,\r\n            pageSize: this.table.paginationManager ? this.table.paginationManager.pageSize : 10\r\n          });\r\n          \r\n          this.table.dataManager.setServerData(result.data, result.totalRows);\r\n        } catch (error) {\r\n          console.error('Failed to clear server sorting:', error);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Update UI and refresh table\r\n    this.table.renderer.updateSortIndicators(null);\r\n    await this.table.refreshTable();\r\n    \r\n    this.table.eventManager.trigger('afterSort', { currentSort: null });\r\n  }\r\n\r\n  /**\r\n   * Get current sort state\r\n   */\r\n  getSortState() {\r\n    return {\r\n      sort: this.currentSort,\r\n      mode: this.options.mode\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set sorting options\r\n   */\r\n  setOptions(newOptions) {\r\n    this.options = { ...this.options, ...newOptions };\r\n  }\r\n\r\n  /**\r\n   * Check if a column is sortable\r\n   */\r\n  isColumnSortable(columnName) {\r\n    if (!this.options.enabled) return false;\r\n    \r\n    const columns = this.table.options.columns || [];\r\n    const column = columns.find(col => col.name === columnName);\r\n    \r\n    return column && column.sortable !== false;\r\n  }\r\n\r\n  /**\r\n   * Get sort direction for a column\r\n   */\r\n  getSortDirection(columnName) {\r\n    return this.currentSort && this.currentSort.column === columnName \r\n      ? this.currentSort.direction \r\n      : null;\r\n  }\r\n}\r\n","/**\r\n * ColumnManager - Enhanced column formatting system for TablixJS\r\n * \r\n * Features:\r\n * - Flexible formatting with optional locale and formatOptions\r\n * - Supports text, date, currency, number, percent formats\r\n * - Custom renderer priority over formatting\r\n * - Extensible design for future format types\r\n * - Performance-optimized with cached formatters\r\n */\r\nexport default class ColumnManager {\r\n  constructor(table) {\r\n    this.table = table;\r\n    this.columns = [];\r\n    this.formatters = new Map(); // Cache for compiled formatters\r\n    this.supportedFormats = ['text', 'date', 'currency', 'number', 'percent'];\r\n  }\r\n\r\n  /**\r\n   * Initialize columns and prepare formatters\r\n   * @param {Array} columns - Array of column definitions\r\n   */\r\n  initializeColumns(columns = []) {\r\n    this.columns = columns.map(col => this.prepareColumn(col));\r\n    this.compileFormatters();\r\n    return this.columns;\r\n  }\r\n\r\n  /**\r\n   * Prepare and validate a single column definition\r\n   * @param {Object} column - Column definition\r\n   * @returns {Object} Prepared column\r\n   */\r\n  prepareColumn(column) {\r\n    const prepared = { ...column };\r\n\r\n    // Validate format if provided\r\n    if (prepared.format && !this.supportedFormats.includes(prepared.format)) {\r\n      console.warn(`TablixJS: Unsupported format type '${prepared.format}' for column '${prepared.name}'. Falling back to no formatting.`);\r\n      delete prepared.format;\r\n    }\r\n\r\n    // Ensure name property exists\r\n    if (!prepared.name) {\r\n      throw new Error('TablixJS: Column must have a \"name\" property');\r\n    }\r\n\r\n    // Set default title if not provided\r\n    if (!prepared.title) {\r\n      prepared.title = prepared.name;\r\n    }\r\n\r\n    return prepared;\r\n  }\r\n\r\n  /**\r\n   * Compile and cache formatter functions for columns with format specified\r\n   */\r\n  compileFormatters() {\r\n    this.formatters.clear();\r\n\r\n    this.columns.forEach(column => {\r\n      if (column.format) {\r\n        const formatter = this.createFormatter(column);\r\n        if (formatter) {\r\n          this.formatters.set(column.name, formatter);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create a formatter function for a column\r\n   * @param {Object} column - Column definition\r\n   * @returns {Function|null} Formatter function\r\n   */\r\n  createFormatter(column) {\r\n    const { format, locale, formatOptions = {} } = column;\r\n\r\n    switch (format) {\r\n      case 'text':\r\n        return (value) => this.formatText(value);\r\n\r\n      case 'date':\r\n        return (value) => this.formatDate(value, locale, formatOptions);\r\n\r\n      case 'currency':\r\n        return (value) => this.formatCurrency(value, locale, formatOptions, column.currency);\r\n\r\n      case 'number':\r\n        return (value) => this.formatNumber(value, locale, formatOptions);\r\n\r\n      case 'percent':\r\n        return (value) => this.formatPercent(value, locale, formatOptions);\r\n\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Format a cell value for a specific column\r\n   * @param {string} columnName - Column name\r\n   * @param {*} value - Cell value\r\n   * @param {Object} row - Full row data (for context)\r\n   * @returns {Object} Object with formatted value and metadata\r\n   */\r\n  formatCellValue(columnName, value, row) {\r\n    const column = this.getColumn(columnName);\r\n    \r\n    // Priority 1: Custom renderer (overrides everything)\r\n    if (column && column.renderer) {\r\n      // If renderer wants formatted value, provide it\r\n      const formatter = this.formatters.get(columnName);\r\n      const formattedValue = formatter ? formatter(value) : value;\r\n      const result = column.renderer(value, row, formattedValue);\r\n      return {\r\n        value: result,\r\n        isHtml: true // Custom renderers can return HTML\r\n      };\r\n    }\r\n\r\n    // Priority 2: Format using cached formatter\r\n    const formatter = this.formatters.get(columnName);\r\n    if (formatter) {\r\n      return {\r\n        value: formatter(value),\r\n        isHtml: false // Formatted values are safe text\r\n      };\r\n    }\r\n\r\n    // Priority 3: Return raw value\r\n    return {\r\n      value: value,\r\n      isHtml: false // Raw values need escaping\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get column definition by name\r\n   * @param {string} columnName - Column name\r\n   * @returns {Object|null} Column definition\r\n   */\r\n  getColumn(columnName) {\r\n    return this.columns.find(col => col.name === columnName) || null;\r\n  }\r\n\r\n  /**\r\n   * Get all columns\r\n   * @returns {Array} Array of column definitions\r\n   */\r\n  getColumns() {\r\n    return this.columns;\r\n  }\r\n\r\n  // =============================================================================\r\n  // FORMAT IMPLEMENTATIONS\r\n  // =============================================================================\r\n\r\n  /**\r\n   * Format text (basic string conversion with null/undefined handling)\r\n   * @param {*} value - Value to format\r\n   * @returns {string} Formatted text\r\n   */\r\n  formatText(value) {\r\n    if (value == null) return '';\r\n    return String(value);\r\n  }\r\n\r\n  /**\r\n   * Format date using Intl.DateTimeFormat\r\n   * @param {*} value - Date value (string, Date, timestamp)\r\n   * @param {string} locale - Locale string (optional)\r\n   * @param {Object} options - Intl.DateTimeFormat options\r\n   * @returns {string} Formatted date\r\n   */\r\n  formatDate(value, locale, options = {}) {\r\n    if (value == null) return '';\r\n\r\n    try {\r\n      const date = value instanceof Date ? value : new Date(value);\r\n      \r\n      if (isNaN(date.getTime())) {\r\n        return String(value); // Return original if invalid date\r\n      }\r\n\r\n      const formatter = new Intl.DateTimeFormat(locale, options);\r\n      return formatter.format(date);\r\n    } catch (error) {\r\n      console.warn('TablixJS: Date formatting error:', error);\r\n      return String(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Format currency using Intl.NumberFormat\r\n   * @param {*} value - Numeric value\r\n   * @param {string} locale - Locale string (optional)\r\n   * @param {Object} options - Intl.NumberFormat options\r\n   * @param {string} currency - Currency code (e.g., 'USD', 'EUR')\r\n   * @returns {string} Formatted currency\r\n   */\r\n  formatCurrency(value, locale, options = {}, currency = 'USD') {\r\n    if (value == null) return '';\r\n\r\n    const numericValue = Number(value);\r\n    if (isNaN(numericValue)) {\r\n      return String(value);\r\n    }\r\n\r\n    try {\r\n      const formatOptions = {\r\n        style: 'currency',\r\n        currency: currency,\r\n        ...options\r\n      };\r\n\r\n      const formatter = new Intl.NumberFormat(locale, formatOptions);\r\n      return formatter.format(numericValue);\r\n    } catch (error) {\r\n      console.warn('TablixJS: Currency formatting error:', error);\r\n      return String(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Format number using Intl.NumberFormat\r\n   * @param {*} value - Numeric value\r\n   * @param {string} locale - Locale string (optional)\r\n   * @param {Object} options - Intl.NumberFormat options\r\n   * @returns {string} Formatted number\r\n   */\r\n  formatNumber(value, locale, options = {}) {\r\n    if (value == null) return '';\r\n\r\n    const numericValue = Number(value);\r\n    if (isNaN(numericValue)) {\r\n      return String(value);\r\n    }\r\n\r\n    try {\r\n      const formatter = new Intl.NumberFormat(locale, options);\r\n      return formatter.format(numericValue);\r\n    } catch (error) {\r\n      console.warn('TablixJS: Number formatting error:', error);\r\n      return String(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Format percentage using Intl.NumberFormat\r\n   * @param {*} value - Numeric value (0.5 = 50%)\r\n   * @param {string} locale - Locale string (optional)\r\n   * @param {Object} options - Intl.NumberFormat options\r\n   * @returns {string} Formatted percentage\r\n   */\r\n  formatPercent(value, locale, options = {}) {\r\n    if (value == null) return '';\r\n\r\n    const numericValue = Number(value);\r\n    if (isNaN(numericValue)) {\r\n      return String(value);\r\n    }\r\n\r\n    try {\r\n      const formatOptions = {\r\n        style: 'percent',\r\n        ...options\r\n      };\r\n\r\n      const formatter = new Intl.NumberFormat(locale, formatOptions);\r\n      return formatter.format(numericValue);\r\n    } catch (error) {\r\n      console.warn('TablixJS: Percent formatting error:', error);\r\n      return String(value);\r\n    }\r\n  }\r\n\r\n  // =============================================================================\r\n  // EXTENSIBILITY METHODS\r\n  // =============================================================================\r\n\r\n  /**\r\n   * Register a custom format type (for future extensibility)\r\n   * @param {string} formatType - Format type name\r\n   * @param {Function} formatterFactory - Function that creates formatter\r\n   */\r\n  registerFormat(formatType, formatterFactory) {\r\n    if (this.supportedFormats.includes(formatType)) {\r\n      console.warn(`TablixJS: Format type '${formatType}' already exists and will be overridden.`);\r\n    }\r\n\r\n    this.supportedFormats.push(formatType);\r\n    \r\n    // You would extend createFormatter method to handle this\r\n    // This is a placeholder for future plugin architecture\r\n    console.log(`TablixJS: Custom format '${formatType}' registered.`);\r\n  }\r\n\r\n  /**\r\n   * Get supported format types\r\n   * @returns {Array} Array of supported format type strings\r\n   */\r\n  getSupportedFormats() {\r\n    return [...this.supportedFormats];\r\n  }\r\n}\r\n","/**\r\n * FilterManager - Advanced column filtering system for TablixJS\r\n * \r\n * Features:\r\n * - Multi-column filtering with independent filter states\r\n * - Two filter types: \"value\" (checkbox selection) and \"condition\" (operators)\r\n * - Supports multiple conditions per column\r\n * - Extensible operator system for custom filters\r\n * - Integration with sorting and pagination\r\n */\r\nexport default class FilterManager {\r\n  constructor(table, options = {}) {\r\n    this.table = table;\r\n    this.options = {\r\n      enabled: true,\r\n      mode: 'client', // 'client' or 'server'\r\n      serverFilterLoader: null, // Function to load filtered data from server\r\n      debounceDelay: 300, // Debounce delay for input filters\r\n      showBadges: true, // Show filter count badges\r\n      showTooltips: true, // Show filter summary tooltips\r\n      ...options\r\n    };\r\n\r\n    // Filter state per column\r\n    this.columnFilters = new Map(); // { columnName: { type, config, isActive } }\r\n    \r\n    // Supported filter operators\r\n    this.operators = {\r\n      'none': { label: 'None', apply: () => true },\r\n      'isEmpty': { label: 'Is empty', apply: (value) => value === null || value === undefined || value === '' },\r\n      'isNotEmpty': { label: 'Is not empty', apply: (value) => value !== null && value !== undefined && value !== '' },\r\n      'equals': { label: 'Is equal to', apply: (value, filterValue) => String(value).toLowerCase() === String(filterValue).toLowerCase() },\r\n      'notEquals': { label: 'Is not equal to', apply: (value, filterValue) => String(value).toLowerCase() !== String(filterValue).toLowerCase() },\r\n      'beginsWith': { label: 'Begins with', apply: (value, filterValue) => String(value).toLowerCase().startsWith(String(filterValue).toLowerCase()) },\r\n      'endsWith': { label: 'Ends with', apply: (value, filterValue) => String(value).toLowerCase().endsWith(String(filterValue).toLowerCase()) },\r\n      'contains': { label: 'Contains', apply: (value, filterValue) => String(value).toLowerCase().includes(String(filterValue).toLowerCase()) },\r\n      'notContains': { label: 'Does not contain', apply: (value, filterValue) => !String(value).toLowerCase().includes(String(filterValue).toLowerCase()) }\r\n    };\r\n\r\n    // Debounce timer for input filtering\r\n    this.debounceTimer = null;\r\n\r\n    // Track open filter dropdowns\r\n    this.openDropdowns = new Set();\r\n  }\r\n\r\n  /**\r\n   * Apply filter to a specific column\r\n   * @param {string} columnName - Column to filter\r\n   * @param {Object} filterConfig - Filter configuration\r\n   */\r\n  async applyFilter(columnName, filterConfig) {\r\n    // Validate filter config\r\n    if (!this.validateFilterConfig(filterConfig)) {\r\n      console.warn(`TablixJS: Invalid filter config for column '${columnName}'`);\r\n      return;\r\n    }\r\n\r\n    // Trigger beforeFilter hook\r\n    const beforeFilterData = { \r\n      columnName, \r\n      filterConfig, \r\n      currentFilters: this.getActiveFilters() \r\n    };\r\n    this.table.eventManager.trigger('beforeFilter', beforeFilterData);\r\n\r\n    // Store filter state\r\n    this.columnFilters.set(columnName, {\r\n      type: filterConfig.type,\r\n      config: filterConfig,\r\n      isActive: this.isFilterActive(filterConfig)\r\n    });\r\n\r\n    if (this.options.mode === 'server') {\r\n      await this._filterServer();\r\n    } else {\r\n      this._filterClient();\r\n    }\r\n\r\n    // Update UI indicators\r\n    this.updateFilterIndicators();\r\n    \r\n    // Refresh table display\r\n    await this.table.refreshTable();\r\n\r\n    // Trigger afterFilter hook\r\n    this.table.eventManager.trigger('afterFilter', {\r\n      columnName,\r\n      filterConfig,\r\n      filteredData: this.table.dataManager.getData(),\r\n      activeFilters: this.getActiveFilters()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clear filter for a specific column\r\n   * @param {string} columnName - Column to clear filter for\r\n   */\r\n  async clearFilter(columnName) {\r\n    if (!this.columnFilters.has(columnName)) return;\r\n\r\n    const beforeFilterData = { \r\n      columnName, \r\n      filterConfig: null, \r\n      currentFilters: this.getActiveFilters() \r\n    };\r\n    this.table.eventManager.trigger('beforeFilter', beforeFilterData);\r\n\r\n    this.columnFilters.delete(columnName);\r\n\r\n    if (this.options.mode === 'server') {\r\n      await this._filterServer();\r\n    } else {\r\n      this._filterClient();\r\n    }\r\n\r\n    this.updateFilterIndicators();\r\n    await this.table.refreshTable();\r\n\r\n    this.table.eventManager.trigger('afterFilter', {\r\n      columnName,\r\n      filterConfig: null,\r\n      filteredData: this.table.dataManager.getData(),\r\n      activeFilters: this.getActiveFilters()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clear all filters\r\n   */\r\n  async clearAllFilters() {\r\n    if (this.columnFilters.size === 0) return;\r\n\r\n    const beforeFilterData = { \r\n      columnName: null, \r\n      filterConfig: null, \r\n      currentFilters: this.getActiveFilters() \r\n    };\r\n    this.table.eventManager.trigger('beforeFilter', beforeFilterData);\r\n\r\n    this.columnFilters.clear();\r\n\r\n    if (this.options.mode === 'server') {\r\n      await this._filterServer();\r\n    } else {\r\n      this._filterClient();\r\n    }\r\n\r\n    this.updateFilterIndicators();\r\n    await this.table.refreshTable();\r\n\r\n    this.table.eventManager.trigger('afterFilter', {\r\n      columnName: null,\r\n      filterConfig: null,\r\n      filteredData: this.table.dataManager.getData(),\r\n      activeFilters: this.getActiveFilters()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get active filters\r\n   * @returns {Object} Active filters by column\r\n   */\r\n  getActiveFilters() {\r\n    const activeFilters = {};\r\n    for (const [columnName, filterState] of this.columnFilters) {\r\n      if (filterState.isActive) {\r\n        activeFilters[columnName] = filterState.config;\r\n      }\r\n    }\r\n    return activeFilters;\r\n  }\r\n\r\n  /**\r\n   * Get unique values for a column (for value filtering)\r\n   * @param {string} columnName - Column name\r\n   * @returns {Array} Unique values\r\n   */\r\n  getColumnUniqueValues(columnName) {\r\n    const data = this.table.dataManager.originalData;\r\n    const values = new Set();\r\n    \r\n    data.forEach(row => {\r\n      const value = row[columnName];\r\n      if (value !== null && value !== undefined) {\r\n        values.add(String(value));\r\n      }\r\n    });\r\n    \r\n    return Array.from(values).sort();\r\n  }\r\n\r\n  /**\r\n   * Get filter state for a column\r\n   * @param {string} columnName - Column name\r\n   * @returns {Object|null} Filter state\r\n   */\r\n  getColumnFilter(columnName) {\r\n    return this.columnFilters.get(columnName) || null;\r\n  }\r\n\r\n  /**\r\n   * Check if column has active filter\r\n   * @param {string} columnName - Column name\r\n   * @returns {boolean} Whether column has active filter\r\n   */\r\n  hasColumnFilter(columnName) {\r\n    const filter = this.columnFilters.get(columnName);\r\n    return filter && filter.isActive;\r\n  }\r\n\r\n  /**\r\n   * Validate filter configuration\r\n   * @param {Object} filterConfig - Filter configuration\r\n   * @returns {boolean} Whether config is valid\r\n   */\r\n  validateFilterConfig(filterConfig) {\r\n    if (!filterConfig || !filterConfig.type) return false;\r\n    \r\n    if (filterConfig.type === 'value') {\r\n      return Array.isArray(filterConfig.values);\r\n    }\r\n    \r\n    if (filterConfig.type === 'condition') {\r\n      return Array.isArray(filterConfig.conditions) && \r\n             filterConfig.conditions.every(cond => \r\n               cond.operator && this.operators[cond.operator]\r\n             );\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if filter config represents an active filter\r\n   * @param {Object} filterConfig - Filter configuration\r\n   * @returns {boolean} Whether filter is active\r\n   */\r\n  isFilterActive(filterConfig) {\r\n    if (!filterConfig) return false;\r\n    \r\n    if (filterConfig.type === 'value') {\r\n      return filterConfig.values && filterConfig.values.length > 0;\r\n    }\r\n    \r\n    if (filterConfig.type === 'condition') {\r\n      return filterConfig.conditions && \r\n             filterConfig.conditions.some(cond => \r\n               cond.operator && cond.operator !== 'none' && \r\n               (cond.operator === 'isEmpty' || cond.operator === 'isNotEmpty' || cond.value !== undefined)\r\n             );\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Client-side filtering\r\n   * @private\r\n   */\r\n  _filterClient() {\r\n    const originalData = this.table.dataManager.originalData;\r\n    const activeFilters = this.getActiveFilters();\r\n    \r\n    let filteredData;\r\n    if (Object.keys(activeFilters).length === 0) {\r\n      // No filters, show all data\r\n      filteredData = [...originalData];\r\n    } else {\r\n      // Apply all active filters\r\n      filteredData = originalData.filter(row => {\r\n        return Object.entries(activeFilters).every(([columnName, filterConfig]) => {\r\n          return this._testRowAgainstFilter(row, columnName, filterConfig);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Update DataManager with filtered data\r\n    this.table.dataManager.setFilteredData(filteredData);\r\n  }\r\n\r\n  /**\r\n   * Server-side filtering\r\n   * @private\r\n   */\r\n  async _filterServer() {\r\n    if (!this.options.serverFilterLoader) {\r\n      console.warn('TablixJS: Server-side filtering enabled but no serverFilterLoader provided');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const result = await this.options.serverFilterLoader({\r\n        filters: this.getActiveFilters(),\r\n        sort: this.table.sortingManager ? this.table.sortingManager.currentSort : null,\r\n        page: this.table.paginationManager ? this.table.paginationManager.currentPage : 1,\r\n        pageSize: this.table.paginationManager ? this.table.paginationManager.pageSize : 10\r\n      });\r\n\r\n      this.table.dataManager.setServerData(result.data, result.totalRows);\r\n    } catch (error) {\r\n      console.error('Failed to load filtered data from server:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test a row against a filter\r\n   * @param {Object} row - Data row\r\n   * @param {string} columnName - Column name\r\n   * @param {Object} filterConfig - Filter configuration\r\n   * @returns {boolean} Whether row passes filter\r\n   * @private\r\n   */\r\n  _testRowAgainstFilter(row, columnName, filterConfig) {\r\n    const cellValue = row[columnName];\r\n    \r\n    if (filterConfig.type === 'value') {\r\n      // Value filter: check if cell value is in selected values\r\n      return filterConfig.values.includes(String(cellValue));\r\n    }\r\n    \r\n    if (filterConfig.type === 'condition') {\r\n      // Condition filter: test all conditions (AND logic)\r\n      return filterConfig.conditions.every(condition => {\r\n        const operator = this.operators[condition.operator];\r\n        if (!operator) return true; // Unknown operator, pass\r\n        \r\n        return operator.apply(cellValue, condition.value);\r\n      });\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Update filter indicators in the UI\r\n   */\r\n  updateFilterIndicators() {\r\n    const headers = this.table.container.querySelectorAll('.tablix-th');\r\n    \r\n    headers.forEach(header => {\r\n      const columnName = header.dataset.column;\r\n      const hasFilter = this.hasColumnFilter(columnName);\r\n      const filterIndicator = header.querySelector('.tablix-filter-indicator');\r\n      \r\n      if (hasFilter) {\r\n        header.classList.add('tablix-filtered');\r\n        if (filterIndicator) {\r\n          filterIndicator.classList.add('tablix-filter-active');\r\n          \r\n          // Update badge if enabled\r\n          if (this.options.showBadges) {\r\n            this._updateFilterBadge(header, columnName);\r\n          }\r\n        }\r\n      } else {\r\n        header.classList.remove('tablix-filtered');\r\n        if (filterIndicator) {\r\n          filterIndicator.classList.remove('tablix-filter-active');\r\n          const badge = filterIndicator.querySelector('.tablix-filter-badge');\r\n          if (badge) badge.remove();\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update filter badge for a column\r\n   * @param {Element} header - Header element\r\n   * @param {string} columnName - Column name\r\n   * @private\r\n   */\r\n  _updateFilterBadge(header, columnName) {\r\n    const filterIndicator = header.querySelector('.tablix-filter-indicator');\r\n    if (!filterIndicator) return;\r\n    \r\n    const filter = this.getColumnFilter(columnName);\r\n    if (!filter || !filter.isActive) return;\r\n    \r\n    let badgeText = '';\r\n    if (filter.type === 'value') {\r\n      badgeText = filter.config.values.length.toString();\r\n    } else if (filter.type === 'condition') {\r\n      const activeConditions = filter.config.conditions.filter(cond => \r\n        cond.operator && cond.operator !== 'none'\r\n      );\r\n      badgeText = activeConditions.length.toString();\r\n    }\r\n    \r\n    let badge = filterIndicator.querySelector('.tablix-filter-badge');\r\n    if (!badge && badgeText) {\r\n      badge = document.createElement('span');\r\n      badge.className = 'tablix-filter-badge';\r\n      filterIndicator.appendChild(badge);\r\n    }\r\n    \r\n    if (badge) {\r\n      badge.textContent = badgeText;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register a custom filter operator\r\n   * @param {string} name - Operator name\r\n   * @param {Object} operator - Operator definition\r\n   */\r\n  registerOperator(name, operator) {\r\n    if (!operator.label || typeof operator.apply !== 'function') {\r\n      throw new Error('TablixJS: Custom operator must have label and apply function');\r\n    }\r\n    \r\n    this.operators[name] = operator;\r\n  }\r\n\r\n  /**\r\n   * Get available operators\r\n   * @returns {Object} Available operators\r\n   */\r\n  getOperators() {\r\n    return { ...this.operators };\r\n  }\r\n}\r\n","/**\r\n * FilterUI - User interface components for TablixJS filtering\r\n * Handles dropdown creation, event binding, and filter interactions\r\n */\r\nexport default class FilterUI {\r\n  constructor(filterManager) {\r\n    this.filterManager = filterManager;\r\n    this.table = filterManager.table;\r\n    \r\n    // Track open dropdowns\r\n    this.activeDropdown = null;\r\n    \r\n    // Bind methods to preserve context\r\n    this.handleDocumentClick = this.handleDocumentClick.bind(this);\r\n    this.handleFilterIconClick = this.handleFilterIconClick.bind(this);\r\n    \r\n    // Initialize event listeners\r\n    this.init();\r\n  }\r\n\r\n  /**\r\n   * Initialize the FilterUI\r\n   */\r\n  init() {\r\n    // Add document click listener to close dropdowns\r\n    document.addEventListener('click', this.handleDocumentClick);\r\n  }\r\n\r\n  /**\r\n   * Destroy FilterUI and clean up event listeners\r\n   */\r\n  destroy() {\r\n    document.removeEventListener('click', this.handleDocumentClick);\r\n    this.closeAllDropdowns();\r\n  }\r\n\r\n  /**\r\n   * Render filter icons in table headers\r\n   */\r\n  renderFilterIcons() {\r\n    const headers = this.table.container.querySelectorAll('.tablix-th');\r\n    \r\n    headers.forEach(header => {\r\n      const columnName = header.dataset.column;\r\n      if (!columnName) return;\r\n      \r\n      // Skip if filter icon already exists\r\n      if (header.querySelector('.tablix-filter-indicator')) return;\r\n      \r\n      const thContent = header.querySelector('.tablix-th-content');\r\n      if (!thContent) return;\r\n      \r\n      // Create filter indicator\r\n      const filterIndicator = document.createElement('span');\r\n      filterIndicator.className = 'tablix-filter-indicator';\r\n      filterIndicator.innerHTML = `\r\n        <span class=\"tablix-filter-icon\" title=\"Filter column\">⚪</span>\r\n      `;\r\n      \r\n      // Add click handler\r\n      filterIndicator.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.handleFilterIconClick(columnName, filterIndicator);\r\n      });\r\n      \r\n      // Insert after sort indicator or at end\r\n      const sortIndicator = thContent.querySelector('.tablix-sort-indicator');\r\n      if (sortIndicator) {\r\n        thContent.insertBefore(filterIndicator, sortIndicator.nextSibling);\r\n      } else {\r\n        thContent.appendChild(filterIndicator);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle filter icon click\r\n   * @param {string} columnName - Column name\r\n   * @param {Element} filterIndicator - Filter indicator element\r\n   */\r\n  handleFilterIconClick(columnName, filterIndicator) {\r\n    // Close any existing dropdown\r\n    this.closeAllDropdowns();\r\n    \r\n    // Create and show dropdown\r\n    const dropdown = this.createFilterDropdown(columnName);\r\n    this.showDropdown(dropdown, filterIndicator);\r\n    this.activeDropdown = { dropdown, columnName };\r\n  }\r\n\r\n  /**\r\n   * Handle document clicks to close dropdowns\r\n   * @param {Event} event - Click event\r\n   */\r\n  handleDocumentClick(event) {\r\n    if (this.activeDropdown) {\r\n      const dropdown = this.activeDropdown.dropdown;\r\n      if (!dropdown.contains(event.target)) {\r\n        this.closeAllDropdowns();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create filter dropdown for a column\r\n   * @param {string} columnName - Column name\r\n   * @returns {Element} Dropdown element\r\n   */\r\n  createFilterDropdown(columnName) {\r\n    const dropdown = document.createElement('div');\r\n    dropdown.className = 'tablix-filter-dropdown';\r\n    dropdown.innerHTML = this.renderDropdownContent(columnName);\r\n    \r\n    // Add event listeners\r\n    this.bindDropdownEvents(dropdown, columnName);\r\n    \r\n    return dropdown;\r\n  }\r\n\r\n  /**\r\n   * Render dropdown content\r\n   * @param {string} columnName - Column name\r\n   * @returns {string} HTML content\r\n   */\r\n  renderDropdownContent(columnName) {\r\n    const currentFilter = this.filterManager.getColumnFilter(columnName);\r\n    \r\n    return `\r\n      <div class=\"tablix-filter-dropdown-header\">\r\n        <h4>Filter: ${columnName}</h4>\r\n        <button class=\"tablix-filter-close\" type=\"button\">×</button>\r\n      </div>\r\n      \r\n      <div class=\"tablix-filter-tabs\">\r\n        <button class=\"tablix-filter-tab ${!currentFilter || currentFilter.type === 'value' ? 'active' : ''}\" \r\n                data-tab=\"value\">Filter by Value</button>\r\n        <button class=\"tablix-filter-tab ${currentFilter && currentFilter.type === 'condition' ? 'active' : ''}\" \r\n                data-tab=\"condition\">Filter by Condition</button>\r\n      </div>\r\n      \r\n      <div class=\"tablix-filter-content\">\r\n        <div class=\"tablix-filter-panel tablix-filter-value-panel ${!currentFilter || currentFilter.type === 'value' ? 'active' : ''}\">\r\n          ${this.renderValueFilterPanel(columnName, currentFilter)}\r\n        </div>\r\n        \r\n        <div class=\"tablix-filter-panel tablix-filter-condition-panel ${currentFilter && currentFilter.type === 'condition' ? 'active' : ''}\">\r\n          ${this.renderConditionFilterPanel(columnName, currentFilter)}\r\n        </div>\r\n      </div>\r\n      \r\n      <div class=\"tablix-filter-actions\">\r\n        <button class=\"tablix-filter-apply\" type=\"button\">Apply</button>\r\n        <button class=\"tablix-filter-clear\" type=\"button\">Clear</button>\r\n        <button class=\"tablix-filter-cancel\" type=\"button\">Cancel</button>\r\n      </div>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Render value filter panel (checkbox list)\r\n   * @param {string} columnName - Column name\r\n   * @param {Object|null} currentFilter - Current filter state\r\n   * @returns {string} HTML content\r\n   */\r\n  renderValueFilterPanel(columnName, currentFilter) {\r\n    const uniqueValues = this.filterManager.getColumnUniqueValues(columnName);\r\n    const selectedValues = currentFilter && currentFilter.type === 'value' ? \r\n      currentFilter.config.values : [];\r\n    \r\n    if (uniqueValues.length === 0) {\r\n      return '<p class=\"tablix-filter-empty\">No values available</p>';\r\n    }\r\n    \r\n    let html = `\r\n      <div class=\"tablix-filter-search\">\r\n        <input type=\"text\" \r\n               id=\"tablix-filter-search-${columnName}\" \r\n               name=\"filter-search-${columnName}\"\r\n               placeholder=\"Search values...\" \r\n               class=\"tablix-filter-search-input\">\r\n      </div>\r\n      <div class=\"tablix-filter-select-all\">\r\n        <label>\r\n          <input type=\"checkbox\" \r\n                 id=\"tablix-filter-select-all-${columnName}\" \r\n                 name=\"filter-select-all-${columnName}\"\r\n                 class=\"tablix-filter-select-all-checkbox\"> Select All\r\n        </label>\r\n      </div>\r\n      <div class=\"tablix-filter-values\">\r\n    `;\r\n    \r\n    uniqueValues.forEach((value, index) => {\r\n      const isChecked = selectedValues.includes(value);\r\n      const valueId = `tablix-filter-value-${columnName}-${index}`;\r\n      html += `\r\n        <label class=\"tablix-filter-value-item\">\r\n          <input type=\"checkbox\" \r\n                 id=\"${valueId}\" \r\n                 name=\"filter-value-${columnName}\" \r\n                 value=\"${this.escapeHtml(value)}\" \r\n                 ${isChecked ? 'checked' : ''}>\r\n          <span class=\"tablix-filter-value-text\">${this.escapeHtml(value)}</span>\r\n        </label>\r\n      `;\r\n    });\r\n    \r\n    html += '</div>';\r\n    return html;\r\n  }\r\n\r\n  /**\r\n   * Render condition filter panel\r\n   * @param {string} columnName - Column name\r\n   * @param {Object|null} currentFilter - Current filter state\r\n   * @returns {string} HTML content\r\n   */\r\n  renderConditionFilterPanel(columnName, currentFilter) {\r\n    const conditions = currentFilter && currentFilter.type === 'condition' ? \r\n      currentFilter.config.conditions : [{ operator: 'none', value: '' }];\r\n    \r\n    let html = '<div class=\"tablix-filter-conditions\">';\r\n    \r\n    conditions.forEach((condition, index) => {\r\n      html += this.renderConditionRow(condition, index);\r\n    });\r\n    \r\n    html += `\r\n      </div>\r\n      <button class=\"tablix-filter-add-condition\" type=\"button\">+ Add Condition</button>\r\n    `;\r\n    \r\n    return html;\r\n  }\r\n\r\n  /**\r\n   * Render a single condition row\r\n   * @param {Object} condition - Condition object\r\n   * @param {number} index - Condition index\r\n   * @returns {string} HTML content\r\n   */\r\n  renderConditionRow(condition, index) {\r\n    const operators = this.filterManager.getOperators();\r\n    const needsValue = condition.operator && \r\n      !['none', 'isEmpty', 'isNotEmpty'].includes(condition.operator);\r\n    \r\n    let html = `\r\n      <div class=\"tablix-filter-condition\" data-index=\"${index}\">\r\n        <select class=\"tablix-filter-operator\" \r\n                id=\"tablix-filter-operator-${index}\" \r\n                name=\"filter-operator-${index}\">\r\n    `;\r\n    \r\n    Object.entries(operators).forEach(([key, op]) => {\r\n      const selected = condition.operator === key ? ' selected' : '';\r\n      html += `<option value=\"${key}\"${selected}>${op.label}</option>`;\r\n    });\r\n    \r\n    html += `\r\n        </select>\r\n        <input type=\"text\" \r\n               id=\"tablix-filter-value-${index}\" \r\n               name=\"filter-value-${index}\"\r\n               class=\"tablix-filter-value\" \r\n               placeholder=\"Value\" \r\n               value=\"${this.escapeHtml(condition.value || '')}\"\r\n               ${needsValue ? '' : 'disabled'}>\r\n        <button class=\"tablix-filter-remove-condition\" \r\n                type=\"button\" \r\n                data-index=\"${index}\"\r\n                title=\"Remove condition\">×</button>\r\n      </div>\r\n    `;\r\n    \r\n    return html;\r\n  }\r\n\r\n  /**\r\n   * Bind dropdown event listeners\r\n   * @param {Element} dropdown - Dropdown element\r\n   * @param {string} columnName - Column name\r\n   */\r\n  bindDropdownEvents(dropdown, columnName) {\r\n    // Tab switching\r\n    dropdown.querySelectorAll('.tablix-filter-tab').forEach(tab => {\r\n      tab.addEventListener('click', (e) => {\r\n        const tabType = e.target.dataset.tab;\r\n        this.switchTab(dropdown, tabType);\r\n      });\r\n    });\r\n\r\n    // Close button\r\n    dropdown.querySelector('.tablix-filter-close').addEventListener('click', () => {\r\n      this.closeAllDropdowns();\r\n    });\r\n\r\n    // Action buttons\r\n    dropdown.querySelector('.tablix-filter-apply').addEventListener('click', () => {\r\n      this.applyFilter(dropdown, columnName);\r\n    });\r\n\r\n    dropdown.querySelector('.tablix-filter-clear').addEventListener('click', () => {\r\n      this.clearFilter(columnName);\r\n    });\r\n\r\n    dropdown.querySelector('.tablix-filter-cancel').addEventListener('click', () => {\r\n      this.closeAllDropdowns();\r\n    });\r\n\r\n    // Value filter events\r\n    this.bindValueFilterEvents(dropdown, columnName);\r\n    \r\n    // Condition filter events\r\n    this.bindConditionFilterEvents(dropdown, columnName);\r\n  }\r\n\r\n  /**\r\n   * Bind value filter events\r\n   * @param {Element} dropdown - Dropdown element\r\n   * @param {string} columnName - Column name\r\n   */\r\n  bindValueFilterEvents(dropdown, columnName) {\r\n    const valuePanel = dropdown.querySelector('.tablix-filter-value-panel');\r\n    if (!valuePanel) return;\r\n\r\n    // Search input with debouncing\r\n    const searchInput = valuePanel.querySelector('.tablix-filter-search-input');\r\n    if (searchInput) {\r\n      let searchTimeout;\r\n      searchInput.addEventListener('input', (e) => {\r\n        clearTimeout(searchTimeout);\r\n        searchTimeout = setTimeout(() => {\r\n          this.filterValueList(valuePanel, e.target.value);\r\n        }, this.filterManager.options.debounceDelay || 150);\r\n      });\r\n    }\r\n\r\n    // Select all checkbox\r\n    const selectAllCheckbox = valuePanel.querySelector('.tablix-filter-select-all-checkbox');\r\n    if (selectAllCheckbox) {\r\n      selectAllCheckbox.addEventListener('change', (e) => {\r\n        this.toggleSelectAll(valuePanel, e.target.checked);\r\n      });\r\n    }\r\n\r\n    // Individual value checkboxes\r\n    valuePanel.querySelectorAll('.tablix-filter-value-item input[type=\"checkbox\"]').forEach(checkbox => {\r\n      checkbox.addEventListener('change', () => {\r\n        this.updateSelectAllState(valuePanel);\r\n      });\r\n    });\r\n\r\n    // Update select all state based on current selections\r\n    this.updateSelectAllState(valuePanel);\r\n  }\r\n\r\n  /**\r\n   * Bind condition filter events\r\n   * @param {Element} dropdown - Dropdown element\r\n   * @param {string} columnName - Column name\r\n   */\r\n  bindConditionFilterEvents(dropdown, columnName) {\r\n    const conditionPanel = dropdown.querySelector('.tablix-filter-condition-panel');\r\n    if (!conditionPanel) return;\r\n\r\n    // Add condition button\r\n    const addButton = conditionPanel.querySelector('.tablix-filter-add-condition');\r\n    if (addButton) {\r\n      addButton.addEventListener('click', () => {\r\n        this.addCondition(conditionPanel);\r\n      });\r\n    }\r\n\r\n    // Operator and value changes\r\n    this.bindConditionRowEvents(conditionPanel);\r\n  }\r\n\r\n  /**\r\n   * Bind events for condition rows\r\n   * @param {Element} conditionPanel - Condition panel element\r\n   */\r\n  bindConditionRowEvents(conditionPanel) {\r\n    // Operator changes\r\n    conditionPanel.querySelectorAll('.tablix-filter-operator').forEach(select => {\r\n      select.addEventListener('change', (e) => {\r\n        const valueInput = e.target.parentElement.querySelector('.tablix-filter-value');\r\n        const needsValue = !['none', 'isEmpty', 'isNotEmpty'].includes(e.target.value);\r\n        valueInput.disabled = !needsValue;\r\n        if (!needsValue) valueInput.value = '';\r\n      });\r\n    });\r\n\r\n    // Remove condition buttons\r\n    conditionPanel.querySelectorAll('.tablix-filter-remove-condition').forEach(button => {\r\n      button.addEventListener('click', (e) => {\r\n        e.preventDefault();\r\n        e.stopPropagation(); // Prevent dropdown from closing\r\n        \r\n        const conditionRow = e.target.closest('.tablix-filter-condition');\r\n        const conditionsContainer = conditionPanel.querySelector('.tablix-filter-conditions');\r\n        \r\n        if (conditionsContainer.querySelectorAll('.tablix-filter-condition').length > 1) {\r\n          conditionRow.remove();\r\n        } else {\r\n          // If it's the last condition, reset it to \"none\" instead of removing\r\n          const operatorSelect = conditionRow.querySelector('.tablix-filter-operator');\r\n          const valueInput = conditionRow.querySelector('.tablix-filter-value');\r\n          operatorSelect.value = 'none';\r\n          valueInput.value = '';\r\n          valueInput.disabled = true;\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Switch between filter tabs\r\n   * @param {Element} dropdown - Dropdown element\r\n   * @param {string} tabType - Tab type ('value' or 'condition')\r\n   */\r\n  switchTab(dropdown, tabType) {\r\n    // Update tab buttons\r\n    dropdown.querySelectorAll('.tablix-filter-tab').forEach(tab => {\r\n      tab.classList.toggle('active', tab.dataset.tab === tabType);\r\n    });\r\n\r\n    // Update panels\r\n    dropdown.querySelectorAll('.tablix-filter-panel').forEach(panel => {\r\n      const isActive = panel.classList.contains(`tablix-filter-${tabType}-panel`);\r\n      panel.classList.toggle('active', isActive);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Filter value list based on search\r\n   * @param {Element} valuePanel - Value panel element\r\n   * @param {string} searchTerm - Search term\r\n   */\r\n  filterValueList(valuePanel, searchTerm) {\r\n    const items = valuePanel.querySelectorAll('.tablix-filter-value-item');\r\n    const term = searchTerm.toLowerCase();\r\n    \r\n    items.forEach(item => {\r\n      const text = item.querySelector('.tablix-filter-value-text').textContent.toLowerCase();\r\n      const matches = text.includes(term);\r\n      item.style.display = matches ? '' : 'none';\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Toggle select all checkboxes\r\n   * @param {Element} valuePanel - Value panel element\r\n   * @param {boolean} checked - Whether to check all\r\n   */\r\n  toggleSelectAll(valuePanel, checked) {\r\n    const checkboxes = valuePanel.querySelectorAll('.tablix-filter-value-item input[type=\"checkbox\"]');\r\n    checkboxes.forEach(checkbox => {\r\n      const item = checkbox.closest('.tablix-filter-value-item');\r\n      if (item.style.display !== 'none') {\r\n        checkbox.checked = checked;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update select all checkbox state\r\n   * @param {Element} valuePanel - Value panel element\r\n   */\r\n  updateSelectAllState(valuePanel) {\r\n    const selectAllCheckbox = valuePanel.querySelector('.tablix-filter-select-all-checkbox');\r\n    if (!selectAllCheckbox) return;\r\n\r\n    const checkboxes = valuePanel.querySelectorAll('.tablix-filter-value-item input[type=\"checkbox\"]');\r\n    const visibleCheckboxes = Array.from(checkboxes).filter(cb => \r\n      cb.closest('.tablix-filter-value-item').style.display !== 'none'\r\n    );\r\n    \r\n    const checkedCount = visibleCheckboxes.filter(cb => cb.checked).length;\r\n    \r\n    selectAllCheckbox.checked = checkedCount > 0 && checkedCount === visibleCheckboxes.length;\r\n    selectAllCheckbox.indeterminate = checkedCount > 0 && checkedCount < visibleCheckboxes.length;\r\n  }\r\n\r\n  /**\r\n   * Add a new condition row\r\n   * @param {Element} conditionPanel - Condition panel element\r\n   */\r\n  addCondition(conditionPanel) {\r\n    const conditionsContainer = conditionPanel.querySelector('.tablix-filter-conditions');\r\n    const newIndex = conditionsContainer.children.length;\r\n    \r\n    const conditionHtml = this.renderConditionRow({ operator: 'none', value: '' }, newIndex);\r\n    conditionsContainer.insertAdjacentHTML('beforeend', conditionHtml);\r\n    \r\n    // Bind events for the new condition only\r\n    const newCondition = conditionsContainer.lastElementChild;\r\n    \r\n    // Bind operator change event\r\n    const operatorSelect = newCondition.querySelector('.tablix-filter-operator');\r\n    operatorSelect.addEventListener('change', (e) => {\r\n      const valueInput = e.target.parentElement.querySelector('.tablix-filter-value');\r\n      const needsValue = !['none', 'isEmpty', 'isNotEmpty'].includes(e.target.value);\r\n      valueInput.disabled = !needsValue;\r\n      if (!needsValue) valueInput.value = '';\r\n    });\r\n\r\n    // Bind remove button event\r\n    const removeButton = newCondition.querySelector('.tablix-filter-remove-condition');\r\n    removeButton.addEventListener('click', (e) => {\r\n      e.preventDefault();\r\n      e.stopPropagation(); // Prevent dropdown from closing\r\n      \r\n      const conditionRow = e.target.closest('.tablix-filter-condition');\r\n      const conditionsContainer = conditionPanel.querySelector('.tablix-filter-conditions');\r\n      \r\n      if (conditionsContainer.querySelectorAll('.tablix-filter-condition').length > 1) {\r\n        conditionRow.remove();\r\n      } else {\r\n        // If it's the last condition, reset it to \"none\" instead of removing\r\n        const operatorSelect = conditionRow.querySelector('.tablix-filter-operator');\r\n        const valueInput = conditionRow.querySelector('.tablix-filter-value');\r\n        operatorSelect.value = 'none';\r\n        valueInput.value = '';\r\n        valueInput.disabled = true;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Apply current filter settings\r\n   * @param {Element} dropdown - Dropdown element\r\n   * @param {string} columnName - Column name\r\n   */\r\n  async applyFilter(dropdown, columnName) {\r\n    const activeTab = dropdown.querySelector('.tablix-filter-tab.active').dataset.tab;\r\n    let filterConfig;\r\n\r\n    if (activeTab === 'value') {\r\n      filterConfig = this.collectValueFilter(dropdown);\r\n    } else {\r\n      filterConfig = this.collectConditionFilter(dropdown);\r\n    }\r\n\r\n    await this.filterManager.applyFilter(columnName, filterConfig);\r\n    this.closeAllDropdowns();\r\n  }\r\n\r\n  /**\r\n   * Collect value filter configuration\r\n   * @param {Element} dropdown - Dropdown element\r\n   * @returns {Object} Filter configuration\r\n   */\r\n  collectValueFilter(dropdown) {\r\n    const valuePanel = dropdown.querySelector('.tablix-filter-value-panel');\r\n    const checkboxes = valuePanel.querySelectorAll('.tablix-filter-value-item input[type=\"checkbox\"]:checked');\r\n    const values = Array.from(checkboxes).map(cb => cb.value);\r\n    \r\n    return {\r\n      type: 'value',\r\n      values: values\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Collect condition filter configuration\r\n   * @param {Element} dropdown - Dropdown element\r\n   * @returns {Object} Filter configuration\r\n   */\r\n  collectConditionFilter(dropdown) {\r\n    const conditionPanel = dropdown.querySelector('.tablix-filter-condition-panel');\r\n    const conditionRows = conditionPanel.querySelectorAll('.tablix-filter-condition');\r\n    \r\n    const conditions = Array.from(conditionRows).map(row => {\r\n      const operator = row.querySelector('.tablix-filter-operator').value;\r\n      const value = row.querySelector('.tablix-filter-value').value;\r\n      \r\n      return { operator, value };\r\n    }).filter(cond => cond.operator !== 'none');\r\n    \r\n    return {\r\n      type: 'condition',\r\n      conditions: conditions\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear filter for column\r\n   * @param {string} columnName - Column name\r\n   */\r\n  async clearFilter(columnName) {\r\n    await this.filterManager.clearFilter(columnName);\r\n    this.closeAllDropdowns();\r\n  }\r\n\r\n  /**\r\n   * Show dropdown positioned relative to trigger element\r\n   * @param {Element} dropdown - Dropdown element\r\n   * @param {Element} trigger - Trigger element\r\n   */\r\n  showDropdown(dropdown, trigger) {\r\n    document.body.appendChild(dropdown);\r\n    \r\n    // Position dropdown\r\n    const triggerRect = trigger.getBoundingClientRect();\r\n    const dropdownRect = dropdown.getBoundingClientRect();\r\n    \r\n    let left = triggerRect.left;\r\n    let top = triggerRect.bottom + 5;\r\n    \r\n    // Adjust if dropdown goes off screen\r\n    if (left + dropdownRect.width > window.innerWidth) {\r\n      left = window.innerWidth - dropdownRect.width - 10;\r\n    }\r\n    \r\n    if (top + dropdownRect.height > window.innerHeight) {\r\n      top = triggerRect.top - dropdownRect.height - 5;\r\n    }\r\n    \r\n    dropdown.style.left = `${Math.max(10, left)}px`;\r\n    dropdown.style.top = `${Math.max(10, top)}px`;\r\n    dropdown.style.display = 'block';\r\n  }\r\n\r\n  /**\r\n   * Close all open dropdowns\r\n   */\r\n  closeAllDropdowns() {\r\n    if (this.activeDropdown) {\r\n      this.activeDropdown.dropdown.remove();\r\n      this.activeDropdown = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Escape HTML to prevent XSS\r\n   * @param {string} text - Text to escape\r\n   * @returns {string} Escaped text\r\n   */\r\n  escapeHtml(text) {\r\n    const div = document.createElement('div');\r\n    div.textContent = text;\r\n    return div.innerHTML;\r\n  }\r\n}\r\n","/**\r\n * SearchManager - Global search functionality for TablixJS\r\n * Provides real-time search across all table columns\r\n */\r\nexport default class SearchManager {\r\n  constructor(table, options = {}) {\r\n    this.table = table;\r\n    this.options = {\r\n      enabled: true,\r\n      placeholder: 'Search...',\r\n      searchDelay: 300, // Debounce delay in milliseconds\r\n      caseSensitive: false,\r\n      searchColumns: [], // Empty array means search all columns\r\n      minLength: 1, // Minimum characters before search starts (changed from 0 to 1)\r\n      ...options\r\n    };\r\n\r\n    // Ensure placeholder is never undefined to prevent \"undefined\" from showing in UI\r\n    if (!this.options.placeholder) {\r\n      this.options.placeholder = 'Search...';\r\n    }\r\n\r\n    // Current search state\r\n    this.currentSearchTerm = '';\r\n    this.searchTimeout = null;\r\n    this.originalData = null;\r\n\r\n    // Bind methods to preserve context\r\n    this.handleSearchInput = this.handleSearchInput.bind(this);\r\n    this.handleSearchClear = this.handleSearchClear.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Initialize search functionality\r\n   */\r\n  init() {\r\n    // Store reference to original data\r\n    this.originalData = this.table.dataManager.originalData;\r\n    \r\n    // Listen for data changes\r\n    this.table.eventManager.on('afterLoad', (data) => {\r\n      this.originalData = data.data || data.source;\r\n      // Reapply search if there's an active search term\r\n      if (this.currentSearchTerm) {\r\n        this.performSearch(this.currentSearchTerm);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Bind search events to UI elements\r\n   */\r\n  bindEvents() {\r\n    const searchInput = this.table.container.querySelector('.tablix-search-input');\r\n    const searchClear = this.table.container.querySelector('.tablix-search-clear');\r\n\r\n    if (searchInput) {\r\n      // Ensure input value matches current search term\r\n      if (this.currentSearchTerm && searchInput.value !== this.currentSearchTerm) {\r\n        searchInput.value = this.currentSearchTerm;\r\n      }\r\n      \r\n      searchInput.addEventListener('input', this.handleSearchInput);\r\n      searchInput.addEventListener('keydown', (e) => {\r\n        if (e.key === 'Escape') {\r\n          this.clearSearch();\r\n        }\r\n      });\r\n    }\r\n\r\n    if (searchClear) {\r\n      searchClear.addEventListener('click', this.handleSearchClear);\r\n    }\r\n\r\n    // Update clear button visibility\r\n    this.updateClearButtonVisibility();\r\n  }\r\n\r\n  /**\r\n   * Handle search input with debouncing\r\n   * @param {Event} event - Input event\r\n   */\r\n  handleSearchInput(event) {\r\n    const searchTerm = event.target.value;\r\n    \r\n    // Clear existing timeout\r\n    if (this.searchTimeout) {\r\n      clearTimeout(this.searchTimeout);\r\n    }\r\n\r\n    // Debounce search based on configurable delay\r\n    this.searchTimeout = setTimeout(() => {\r\n      this.performSearch(searchTerm);\r\n    }, this.options.searchDelay);\r\n  }\r\n\r\n  /**\r\n   * Handle search clear button\r\n   * @param {Event} event - Click event\r\n   */\r\n  handleSearchClear(event) {\r\n    event.preventDefault();\r\n    this.clearSearch();\r\n  }\r\n\r\n  /**\r\n   * Perform the actual search\r\n   * @param {string} searchTerm - Search term\r\n   */\r\n  async performSearch(searchTerm) {\r\n    const previousTerm = this.currentSearchTerm;\r\n    \r\n    // Capture focus state before performing search\r\n    const searchInput = this.table.container.querySelector('.tablix-search-input');\r\n    const hadFocus = searchInput && document.activeElement === searchInput;\r\n    const cursorPosition = searchInput ? searchInput.selectionStart || 0 : 0;\r\n    \r\n    // Trigger beforeSearch event with more detailed information\r\n    const beforeSearchData = { \r\n      searchTerm, \r\n      previousTerm,\r\n      minLength: this.options.minLength,\r\n      searchDelay: this.options.searchDelay,\r\n      willSearch: searchTerm.length >= this.options.minLength\r\n    };\r\n    \r\n    this.table.eventManager.trigger('beforeSearch', beforeSearchData);\r\n\r\n    this.currentSearchTerm = searchTerm;\r\n\r\n    // If search term is below minimum length, show all data\r\n    if (searchTerm.length < this.options.minLength) {\r\n      this.table.dataManager.filteredData = [...this.originalData];\r\n    } else {\r\n      // Filter data based on search term\r\n      const filteredData = this.filterData(searchTerm);\r\n      this.table.dataManager.filteredData = filteredData;\r\n    }\r\n\r\n    // Reset pagination to first page\r\n    if (this.table.paginationManager) {\r\n      this.table.paginationManager.resetToFirstPage();\r\n    }\r\n\r\n    // Refresh table display\r\n    await this.table.refreshTable();\r\n\r\n    // Restore focus after table refresh if it had focus before\r\n    if (hadFocus) {\r\n      requestAnimationFrame(() => {\r\n        const newSearchInput = this.table.container.querySelector('.tablix-search-input');\r\n        if (newSearchInput) {\r\n          newSearchInput.focus();\r\n          if (cursorPosition > 0 && cursorPosition <= newSearchInput.value.length) {\r\n            newSearchInput.setSelectionRange(cursorPosition, cursorPosition);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // Trigger afterSearch event with detailed results\r\n    const afterSearchData = {\r\n      searchTerm,\r\n      previousTerm,\r\n      resultsCount: this.table.dataManager.filteredData.length,\r\n      totalCount: this.originalData.length,\r\n      isActive: this.isSearchActive(),\r\n      searchPerformed: searchTerm.length >= this.options.minLength\r\n    };\r\n    \r\n    this.table.eventManager.trigger('afterSearch', afterSearchData);\r\n\r\n    // Update search clear button visibility\r\n    this.updateClearButtonVisibility();\r\n  }\r\n\r\n  /**\r\n   * Filter data based on search term\r\n   * @param {string} searchTerm - Search term\r\n   * @returns {Array} Filtered data\r\n   */\r\n  filterData(searchTerm) {\r\n    if (!searchTerm || searchTerm.trim() === '') {\r\n      return [...this.originalData];\r\n    }\r\n\r\n    const term = this.options.caseSensitive ? searchTerm : searchTerm.toLowerCase();\r\n    const columns = this.getSearchableColumns();\r\n\r\n    return this.originalData.filter(row => {\r\n      return columns.some(columnName => {\r\n        const cellValue = row[columnName];\r\n        if (cellValue === null || cellValue === undefined) {\r\n          return false;\r\n        }\r\n\r\n        const stringValue = this.options.caseSensitive ? \r\n          String(cellValue) : \r\n          String(cellValue).toLowerCase();\r\n\r\n        return stringValue.includes(term);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get columns to search in\r\n   * @returns {Array} Array of column names\r\n   */\r\n  getSearchableColumns() {\r\n    // If specific columns are configured, use those\r\n    if (this.options.searchColumns && this.options.searchColumns.length > 0) {\r\n      return this.options.searchColumns;\r\n    }\r\n\r\n    // Otherwise, search all available columns\r\n    const columns = this.table.columnManager ? \r\n      this.table.columnManager.getColumns() : \r\n      (this.table.options.columns || []);\r\n\r\n    return columns.map(col => col.name || col.key).filter(name => name);\r\n  }\r\n\r\n  /**\r\n   * Clear search\r\n   */\r\n  async clearSearch() {\r\n    // Clear search input using the helper method\r\n    this.updateInputValue('');\r\n\r\n    // Clear search timeout\r\n    if (this.searchTimeout) {\r\n      clearTimeout(this.searchTimeout);\r\n      this.searchTimeout = null;\r\n    }\r\n\r\n    // Perform empty search to reset data\r\n    await this.performSearch('');\r\n  }\r\n\r\n  /**\r\n   * Update clear button visibility\r\n   */\r\n  updateClearButtonVisibility() {\r\n    const searchClear = this.table.container.querySelector('.tablix-search-clear');\r\n    if (searchClear) {\r\n      searchClear.style.display = this.currentSearchTerm ? 'block' : 'none';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update input value without triggering search\r\n   * @param {string} value - Value to set\r\n   */\r\n  updateInputValue(value) {\r\n    const searchInput = this.table.container.querySelector('.tablix-search-input');\r\n    if (searchInput && searchInput.value !== value) {\r\n      searchInput.value = value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set search term programmatically\r\n   * @param {string} searchTerm - Search term\r\n   */\r\n  async setSearchTerm(searchTerm) {\r\n    // Update input value\r\n    this.updateInputValue(searchTerm);\r\n    \r\n    // Clear any pending search timeout\r\n    if (this.searchTimeout) {\r\n      clearTimeout(this.searchTimeout);\r\n      this.searchTimeout = null;\r\n    }\r\n    \r\n    // Perform search immediately\r\n    await this.performSearch(searchTerm);\r\n  }\r\n\r\n  /**\r\n   * Get current search term\r\n   * @returns {string} Current search term\r\n   */\r\n  getSearchTerm() {\r\n    return this.currentSearchTerm;\r\n  }\r\n\r\n  /**\r\n   * Check if search is active\r\n   * @returns {boolean} Whether search is active\r\n   */\r\n  isSearchActive() {\r\n    return this.currentSearchTerm && this.currentSearchTerm.length >= this.options.minLength;\r\n  }\r\n\r\n  /**\r\n   * Get search results count\r\n   * @returns {Object} Search results information\r\n   */\r\n  getSearchInfo() {\r\n    return {\r\n      searchTerm: this.currentSearchTerm,\r\n      resultsCount: this.table.dataManager.filteredData.length,\r\n      totalCount: this.originalData.length,\r\n      isActive: this.isSearchActive()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Configure search options\r\n   * @param {Object} newOptions - New options to merge\r\n   */\r\n  configure(newOptions) {\r\n    const oldOptions = { ...this.options };\r\n    this.options = { ...this.options, ...newOptions };\r\n    \r\n    // Ensure placeholder is never undefined\r\n    if (!this.options.placeholder) {\r\n      this.options.placeholder = 'Search...';\r\n    }\r\n    \r\n    // Update placeholder if it changed\r\n    if (newOptions.placeholder && newOptions.placeholder !== oldOptions.placeholder) {\r\n      const searchInput = this.table.container.querySelector('.tablix-search-input');\r\n      if (searchInput) {\r\n        searchInput.placeholder = this.options.placeholder;\r\n      }\r\n    }\r\n    \r\n    // If minLength changed and we have an active search, re-evaluate\r\n    if (newOptions.minLength !== undefined && this.currentSearchTerm) {\r\n      this.performSearch(this.currentSearchTerm);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current search configuration\r\n   * @returns {Object} Current search options\r\n   */\r\n  getConfiguration() {\r\n    return { ...this.options };\r\n  }\r\n\r\n  /**\r\n   * Destroy search manager and clean up\r\n   */\r\n  destroy() {\r\n    if (this.searchTimeout) {\r\n      clearTimeout(this.searchTimeout);\r\n    }\r\n\r\n    const searchInput = this.table.container.querySelector('.tablix-search-input');\r\n    const searchClear = this.table.container.querySelector('.tablix-search-clear');\r\n\r\n    if (searchInput) {\r\n      searchInput.removeEventListener('input', this.handleSearchInput);\r\n    }\r\n\r\n    if (searchClear) {\r\n      searchClear.removeEventListener('click', this.handleSearchClear);\r\n    }\r\n  }\r\n}\r\n","export default class SelectionManager {\r\n  constructor(table, options = {}) {\r\n    this.table = table;\r\n    this.options = {\r\n      enabled: false,\r\n      mode: 'single', // 'single' or 'multi'\r\n      ...options\r\n    };\r\n    \r\n    // Selection state - use stable data IDs/keys, not row indexes\r\n    this.selectedRows = new Set(); // Set of row IDs/keys\r\n    this.lastSelectedRow = null; // For range selection with shift+click\r\n    \r\n    // Track row ID mapping for stable selection across pagination/sorting/filtering\r\n    this.rowIdMap = new Map(); // Maps data objects to their stable IDs\r\n    this.dataIdKey = options.dataIdKey || 'id'; // Key to use as stable row ID\r\n    \r\n    // Drag selection state\r\n    this.dragSelection = {\r\n      isActive: false,\r\n      startRowIndex: null,\r\n      currentRowIndex: null,\r\n      startRowId: null,\r\n      originalSelection: null, // Backup of selection before drag started\r\n      isDragging: false,\r\n      dragThreshold: 3 // Minimum pixels to move before considering it a drag\r\n    };\r\n    \r\n    this.init();\r\n  }\r\n\r\n  init() {\r\n    this.eventListenersSetup = false; // Track if event listeners are already set up\r\n    \r\n    if (this.options.enabled) {\r\n      this.setupEventListeners();\r\n    }\r\n  }\r\n\r\n  setupEventListeners() {\r\n    // Prevent setting up listeners multiple times\r\n    if (this.eventListenersSetup) {\r\n      return;\r\n    }\r\n    \r\n    this.eventListenersSetup = true;\r\n    \r\n    // Listen for row clicks\r\n    this.table.eventManager.on('rowClick', (event) => {\r\n      this.handleRowClick(event);\r\n    });\r\n    \r\n    // Listen for drag selection events (only in multi mode and when NOT using virtual scrolling)\r\n    if (this.options.mode === 'multi' && !this.table.virtualScrollManager) {\r\n      this.setupDragSelection();\r\n    }\r\n    \r\n    // Clear selection when data changes\r\n    this.table.eventManager.on('beforeLoad', () => {\r\n      this.clearSelection();\r\n    });\r\n    \r\n    // Update selection state after data operations\r\n    this.table.eventManager.on('afterLoad', () => {\r\n      this.updateSelectionAfterDataChange();\r\n    });\r\n    \r\n    // Update selection UI after rendering\r\n    this.table.eventManager.on('afterRender', () => {\r\n      this.updateUI();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle row click events for selection\r\n   * @param {Object} event - Row click event data\r\n   */\r\n  handleRowClick(event) {\r\n    if (!this.options.enabled) {\r\n      return;\r\n    }\r\n\r\n    // If this was a drag operation, don't process as a click\r\n    if (this.dragSelection.isDragging) {\r\n      this.dragSelection.isDragging = false;\r\n      return;\r\n    }\r\n\r\n    const { rowData, rowIndex, originalEvent } = event;\r\n    const rowId = this.getRowId(rowData);\r\n    \r\n    // Debug logging for modifier keys\r\n    console.log('SelectionManager handleRowClick:', {\r\n      rowId,\r\n      hasOriginalEvent: !!originalEvent,\r\n      ctrlKey: originalEvent ? originalEvent.ctrlKey : 'no event',\r\n      shiftKey: originalEvent ? originalEvent.shiftKey : 'no event',\r\n      metaKey: originalEvent ? originalEvent.metaKey : 'no event',\r\n      timestamp: Date.now()\r\n    });\r\n    \r\n    // Prevent default and stop propagation to avoid duplicate events\r\n    if (originalEvent) {\r\n      originalEvent.preventDefault();\r\n      originalEvent.stopPropagation();\r\n    }\r\n\r\n    // Fire beforeSelect event\r\n    const beforeSelectEvent = {\r\n      rowData,\r\n      rowId,\r\n      currentSelection: Array.from(this.selectedRows),\r\n      isCtrlClick: originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey),\r\n      isShiftClick: originalEvent && originalEvent.shiftKey,\r\n      isDragSelection: false\r\n    };\r\n    \r\n    this.table.eventManager.trigger('beforeSelect', beforeSelectEvent);\r\n\r\n    if (this.options.mode === 'single') {\r\n      this.handleSingleSelection(rowId, rowData);\r\n    } else if (this.options.mode === 'multi') {\r\n      this.handleMultiSelection(rowId, rowData, originalEvent);\r\n    }\r\n\r\n    this.updateUI();\r\n    \r\n    // Fire afterSelect event\r\n    const afterSelectEvent = {\r\n      rowData,\r\n      rowId,\r\n      selectedRows: Array.from(this.selectedRows),\r\n      selectedData: this.getSelectedData(),\r\n      isDragSelection: false\r\n    };\r\n    \r\n    this.table.eventManager.trigger('afterSelect', afterSelectEvent);\r\n  }\r\n\r\n  /**\r\n   * Handle single row selection\r\n   * @param {String} rowId - Stable row identifier\r\n   * @param {Object} rowData - Row data object\r\n   */\r\n  handleSingleSelection(rowId, rowData) {\r\n    // In single mode, if the row is already selected, deselect it\r\n    if (this.selectedRows.has(rowId)) {\r\n      this.selectedRows.clear();\r\n      this.lastSelectedRow = null;\r\n    } else {\r\n      // Otherwise, select only the clicked row\r\n      this.selectedRows.clear();\r\n      this.selectedRows.add(rowId);\r\n      this.lastSelectedRow = rowId;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle multi row selection with ctrl+click and shift+click\r\n   * @param {String} rowId - Stable row identifier\r\n   * @param {Object} rowData - Row data object\r\n   * @param {Event} originalEvent - Original mouse event\r\n   */\r\n  handleMultiSelection(rowId, rowData, originalEvent) {\r\n    const isCtrlClick = originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey);\r\n    const isShiftClick = originalEvent && originalEvent.shiftKey;\r\n\r\n    console.log('handleMultiSelection DETAILED:', {\r\n      rowId,\r\n      isCtrlClick,\r\n      isShiftClick,\r\n      'originalEvent.ctrlKey': originalEvent ? originalEvent.ctrlKey : 'no event',\r\n      'originalEvent.metaKey': originalEvent ? originalEvent.metaKey : 'no event',\r\n      'originalEvent.shiftKey': originalEvent ? originalEvent.shiftKey : 'no event',\r\n      lastSelectedRow: this.lastSelectedRow,\r\n      currentSelection: Array.from(this.selectedRows),\r\n      selectionSize: this.selectedRows.size\r\n    });\r\n\r\n    if (isShiftClick && this.lastSelectedRow) {\r\n      // Range selection: select all rows between last selected and current\r\n      console.log('Executing range selection from', this.lastSelectedRow, 'to', rowId);\r\n      this.handleRangeSelection(rowId);\r\n    } else if (isCtrlClick) {\r\n      // Toggle selection of individual row\r\n      console.log('Executing ctrl+click toggle for', rowId);\r\n      if (this.selectedRows.has(rowId)) {\r\n        this.selectedRows.delete(rowId);\r\n        console.log('Ctrl+click: Deselected', rowId);\r\n        // Update lastSelectedRow to another selected row or null\r\n        this.lastSelectedRow = this.selectedRows.size > 0 ? Array.from(this.selectedRows)[0] : null;\r\n      } else {\r\n        this.selectedRows.add(rowId);\r\n        this.lastSelectedRow = rowId;\r\n        console.log('Ctrl+click: Added', rowId, 'to selection. Total selected:', this.selectedRows.size);\r\n      }\r\n    } else {\r\n      // Normal click: select only this row (clear previous selection)\r\n      console.log('Executing normal click for', rowId);\r\n      this.selectedRows.clear();\r\n      this.selectedRows.add(rowId);\r\n      this.lastSelectedRow = rowId;\r\n      console.log('Normal click: Selected only', rowId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle range selection with shift+click\r\n   * @param {String} endRowId - End row ID for range selection\r\n   */\r\n  handleRangeSelection(endRowId) {\r\n    const fullData = this.getFullData();\r\n    \r\n    // Find indices in the full dataset\r\n    const startIndex = fullData.findIndex(row => this.getRowId(row) === this.lastSelectedRow);\r\n    const endIndex = fullData.findIndex(row => this.getRowId(row) === endRowId);\r\n\r\n    if (startIndex === -1 || endIndex === -1) {\r\n      // Fallback to single selection if we can't find the range\r\n      this.selectedRows.clear();\r\n      this.selectedRows.add(endRowId);\r\n      this.lastSelectedRow = endRowId;\r\n      return;\r\n    }\r\n\r\n    // Select all rows in range\r\n    const minIndex = Math.min(startIndex, endIndex);\r\n    const maxIndex = Math.max(startIndex, endIndex);\r\n    \r\n    for (let i = minIndex; i <= maxIndex; i++) {\r\n      const rowId = this.getRowId(fullData[i]);\r\n      this.selectedRows.add(rowId);\r\n    }\r\n  }\r\n\r\n  // ===== DRAG SELECTION METHODS =====\r\n\r\n  /**\r\n   * Setup drag selection event listeners\r\n   */\r\n  setupDragSelection() {\r\n    const tableElement = this.table.container;\r\n    if (!tableElement) return;\r\n\r\n    let startX, startY;\r\n\r\n    // Mouse down on table body\r\n    tableElement.addEventListener('mousedown', (e) => {\r\n      if (!this.options.enabled || this.options.mode !== 'multi') return;\r\n      \r\n      const row = e.target.closest('.tablix-row');\r\n      if (!row || row.classList.contains('tablix-empty-row')) return;\r\n\r\n      const globalRowIndex = parseInt(row.dataset.rowIndex, 10);\r\n      if (isNaN(globalRowIndex)) return;\r\n\r\n      // Only start drag selection if not using modifier keys\r\n      if (e.ctrlKey || e.metaKey || e.shiftKey) return;\r\n\r\n      startX = e.clientX;\r\n      startY = e.clientY;\r\n\r\n      this.dragSelection.isActive = true;\r\n      this.dragSelection.startRowIndex = globalRowIndex; // Store global index\r\n      this.dragSelection.currentRowIndex = globalRowIndex;\r\n      this.dragSelection.isDragging = false;\r\n      \r\n      // Store original selection for potential restoration\r\n      this.dragSelection.originalSelection = new Set(this.selectedRows);\r\n\r\n      // Get start row data using global index\r\n      const fullData = this.getFullData();\r\n      if (globalRowIndex < fullData.length) {\r\n        this.dragSelection.startRowId = this.getRowId(fullData[globalRowIndex]);\r\n      }\r\n\r\n      e.preventDefault();\r\n    });\r\n\r\n    // Mouse move - handle drag selection\r\n    tableElement.addEventListener('mousemove', (e) => {\r\n      if (!this.dragSelection.isActive) return;\r\n\r\n      const deltaX = Math.abs(e.clientX - startX);\r\n      const deltaY = Math.abs(e.clientY - startY);\r\n\r\n      // Check if we've moved enough to consider it a drag\r\n      if (!this.dragSelection.isDragging && \r\n          (deltaX > this.dragSelection.dragThreshold || deltaY > this.dragSelection.dragThreshold)) {\r\n        this.dragSelection.isDragging = true;\r\n        this.startDragSelection();\r\n      }\r\n\r\n      if (this.dragSelection.isDragging) {\r\n        this.updateDragSelection(e);\r\n      }\r\n    });\r\n\r\n    // Mouse up - complete drag selection\r\n    tableElement.addEventListener('mouseup', (e) => {\r\n      if (this.dragSelection.isActive) {\r\n        this.completeDragSelection();\r\n      }\r\n    });\r\n\r\n    // Mouse leave - cancel drag selection\r\n    tableElement.addEventListener('mouseleave', (e) => {\r\n      if (this.dragSelection.isActive) {\r\n        this.cancelDragSelection();\r\n      }\r\n    });\r\n\r\n    // Prevent text selection during drag\r\n    tableElement.addEventListener('selectstart', (e) => {\r\n      if (this.dragSelection.isDragging) {\r\n        e.preventDefault();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start drag selection\r\n   */\r\n  startDragSelection() {\r\n    // Add drag selection class to table for styling\r\n    const tableWrapper = this.table.container.querySelector('.tablix-wrapper');\r\n    if (tableWrapper) {\r\n      tableWrapper.classList.add('tablix-drag-selecting');\r\n    }\r\n\r\n    // Fire beforeSelect event for drag start\r\n    const fullData = this.getFullData();\r\n    if (this.dragSelection.startRowIndex < fullData.length) {\r\n      const startRowData = fullData[this.dragSelection.startRowIndex];\r\n      const beforeSelectEvent = {\r\n        rowData: startRowData,\r\n        rowId: this.dragSelection.startRowId,\r\n        currentSelection: Array.from(this.selectedRows),\r\n        isCtrlClick: false,\r\n        isShiftClick: false,\r\n        isDragSelection: true,\r\n        dragStart: true\r\n      };\r\n      \r\n      this.table.eventManager.trigger('beforeSelect', beforeSelectEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update drag selection based on current mouse position\r\n   */\r\n  updateDragSelection(event) {\r\n    const row = event.target.closest('.tablix-row');\r\n    if (!row || row.classList.contains('tablix-empty-row')) return;\r\n\r\n    const globalRowIndex = parseInt(row.dataset.rowIndex, 10);\r\n    if (isNaN(globalRowIndex)) return;\r\n\r\n    if (globalRowIndex !== this.dragSelection.currentRowIndex) {\r\n      this.dragSelection.currentRowIndex = globalRowIndex;\r\n      this.applyDragSelection();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply current drag selection range\r\n   */\r\n  applyDragSelection() {\r\n    // Always use full dataset for drag selection (global indices)\r\n    const fullData = this.getFullData();\r\n    \r\n    // Calculate selection range using global indices\r\n    const startIndex = this.dragSelection.startRowIndex;\r\n    const endIndex = this.dragSelection.currentRowIndex;\r\n    const minIndex = Math.min(startIndex, endIndex);\r\n    const maxIndex = Math.max(startIndex, endIndex);\r\n\r\n    // Start with original selection (preserve existing selections)\r\n    this.selectedRows = new Set(this.dragSelection.originalSelection);\r\n\r\n    // Add drag range to selection\r\n    for (let i = minIndex; i <= maxIndex; i++) {\r\n      if (i < fullData.length) {\r\n        const rowId = this.getRowId(fullData[i]);\r\n        this.selectedRows.add(rowId);\r\n      }\r\n    }\r\n\r\n    // Update last selected row\r\n    if (endIndex < fullData.length) {\r\n      this.lastSelectedRow = this.getRowId(fullData[endIndex]);\r\n    }\r\n\r\n    // Update UI immediately for responsive feedback\r\n    this.updateUI();\r\n  }\r\n\r\n  /**\r\n   * Complete drag selection\r\n   */\r\n  completeDragSelection() {\r\n    const tableWrapper = this.table.container.querySelector('.tablix-wrapper');\r\n    if (tableWrapper) {\r\n      tableWrapper.classList.remove('tablix-drag-selecting');\r\n    }\r\n\r\n    if (this.dragSelection.isDragging) {\r\n      // Fire final afterSelect event\r\n      const afterSelectEvent = {\r\n        selectedRows: Array.from(this.selectedRows),\r\n        selectedData: this.getSelectedData(),\r\n        isDragSelection: true,\r\n        dragComplete: true\r\n      };\r\n      \r\n      this.table.eventManager.trigger('afterSelect', afterSelectEvent);\r\n    }\r\n\r\n    this.resetDragSelection();\r\n  }\r\n\r\n  /**\r\n   * Cancel drag selection and restore original state\r\n   */\r\n  cancelDragSelection() {\r\n    const tableWrapper = this.table.container.querySelector('.tablix-wrapper');\r\n    if (tableWrapper) {\r\n      tableWrapper.classList.remove('tablix-drag-selecting');\r\n    }\r\n\r\n    // Restore original selection\r\n    this.selectedRows = new Set(this.dragSelection.originalSelection);\r\n    this.updateUI();\r\n\r\n    this.resetDragSelection();\r\n  }\r\n\r\n  /**\r\n   * Reset drag selection state\r\n   */\r\n  resetDragSelection() {\r\n    this.dragSelection.isActive = false;\r\n    this.dragSelection.startRowIndex = null;\r\n    this.dragSelection.currentRowIndex = null;\r\n    this.dragSelection.startRowId = null;\r\n    this.dragSelection.originalSelection = null;\r\n    this.dragSelection.isDragging = false;\r\n  }\r\n\r\n  /**\r\n   * Get stable row ID from row data\r\n   * @param {Object} rowData - Row data object\r\n   * @returns {String} Stable row identifier\r\n   */\r\n  getRowId(rowData) {\r\n    if (typeof rowData[this.dataIdKey] !== 'undefined') {\r\n      return String(rowData[this.dataIdKey]);\r\n    }\r\n    \r\n    // Fallback: create a hash of the row data for identification\r\n    return this.createRowHash(rowData);\r\n  }\r\n\r\n  /**\r\n   * Create a simple hash from row data for identification\r\n   * @param {Object} rowData - Row data object\r\n   * @returns {String} Hash string\r\n   */\r\n  createRowHash(rowData) {\r\n    const str = JSON.stringify(rowData);\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    return String(hash);\r\n  }\r\n\r\n  /**\r\n   * Get current page data for range selection\r\n   * @returns {Array} Current page data\r\n   */\r\n  getCurrentPageData() {\r\n    // If using virtual scrolling, return full dataset\r\n    if (this.table.virtualScrollManager) {\r\n      return this.table.dataManager.getData();\r\n    }\r\n    // Otherwise use pagination if available\r\n    if (this.table.paginationManager) {\r\n      return this.table.paginationManager.getCurrentPageData() || [];\r\n    }\r\n    return this.table.dataManager.getData();\r\n  }\r\n\r\n  /**\r\n   * Get the full dataset for virtual scrolling operations\r\n   * @returns {Array} Full dataset\r\n   */\r\n  getFullData() {\r\n    return this.table.dataManager.getData();\r\n  }\r\n\r\n  /**\r\n   * Update UI to reflect current selection\r\n   */\r\n  updateUI() {\r\n    if (!this.options.enabled) {\r\n      return;\r\n    }\r\n\r\n    const tableElement = this.table.container.querySelector('.tablix-table');\r\n    if (!tableElement) {\r\n      return;\r\n    }\r\n\r\n    // Remove existing selection classes\r\n    const allRows = tableElement.querySelectorAll('.tablix-row');\r\n    allRows.forEach(row => {\r\n      row.classList.remove('tablix-selected', 'tablix-last-selected');\r\n    });\r\n\r\n    // Check if we're in virtual scroll mode by looking for data-virtual-index attributes\r\n    const hasVirtualIndexes = allRows.length > 0 && allRows[0].hasAttribute('data-virtual-index');\r\n    \r\n    if (hasVirtualIndexes) {\r\n      // Virtual scrolling mode: use data-virtual-index to match against full dataset\r\n      const fullData = this.getFullData();\r\n      allRows.forEach((row) => {\r\n        const virtualIndex = parseInt(row.getAttribute('data-virtual-index'));\r\n        if (!isNaN(virtualIndex) && virtualIndex < fullData.length) {\r\n          const rowData = fullData[virtualIndex];\r\n          const rowId = this.getRowId(rowData);\r\n          \r\n          if (this.selectedRows.has(rowId)) {\r\n            row.classList.add('tablix-selected');\r\n            \r\n            // Mark the last selected row for special styling\r\n            if (rowId === this.lastSelectedRow) {\r\n              row.classList.add('tablix-last-selected');\r\n            }\r\n          }\r\n        }\r\n      });\r\n    } else {\r\n      // Regular mode: match by global row index with full dataset\r\n      const fullData = this.getFullData();\r\n      allRows.forEach((row) => {\r\n        // Get global row index from data attribute\r\n        const globalRowIndex = row.hasAttribute('data-row-index') ? \r\n          parseInt(row.getAttribute('data-row-index')) : -1;\r\n          \r\n        if (globalRowIndex >= 0 && globalRowIndex < fullData.length) {\r\n          const rowData = fullData[globalRowIndex];\r\n          const rowId = this.getRowId(rowData);\r\n          \r\n          if (this.selectedRows.has(rowId)) {\r\n            row.classList.add('tablix-selected');\r\n            \r\n            // Mark the last selected row for special styling\r\n            if (rowId === this.lastSelectedRow) {\r\n              row.classList.add('tablix-last-selected');\r\n            }\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update selection state after data changes (pagination, filtering, sorting)\r\n   */\r\n  updateSelectionAfterDataChange() {\r\n    if (!this.options.enabled) {\r\n      return;\r\n    }\r\n\r\n    if (this.table.virtualScrollManager) {\r\n      // For virtual scrolling: keep all selections as the data is the same, just rendered differently\r\n      // Only need to update UI\r\n      this.updateUI();\r\n    } else {\r\n      // For pagination: keep all selections, but validate they still exist in the full dataset\r\n      const fullData = this.getFullData();\r\n      const allDataRowIds = new Set(fullData.map(row => this.getRowId(row)));\r\n      \r\n      // Remove selections for rows that no longer exist in the dataset at all\r\n      const newSelection = new Set();\r\n      this.selectedRows.forEach(rowId => {\r\n        if (allDataRowIds.has(rowId)) {\r\n          newSelection.add(rowId);\r\n        }\r\n      });\r\n      \r\n      this.selectedRows = newSelection;\r\n      \r\n      // Update last selected row if it no longer exists in the dataset\r\n      if (this.lastSelectedRow && !allDataRowIds.has(this.lastSelectedRow)) {\r\n        this.lastSelectedRow = this.selectedRows.size > 0 ? Array.from(this.selectedRows)[0] : null;\r\n      }\r\n      \r\n      this.updateUI();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get selected row data\r\n   * @returns {Array} Array of selected row data objects\r\n   */\r\n  getSelectedData() {\r\n    if (!this.options.enabled || this.selectedRows.size === 0) {\r\n      return [];\r\n    }\r\n\r\n    // Get all data (including filtered/sorted) to find selected rows\r\n    const allData = this.getFullData();\r\n    return allData.filter(row => this.selectedRows.has(this.getRowId(row)));\r\n  }\r\n\r\n  /**\r\n   * Get selected row IDs\r\n   * @returns {Array} Array of selected row IDs\r\n   */\r\n  getSelectedIds() {\r\n    return Array.from(this.selectedRows);\r\n  }\r\n\r\n  /**\r\n   * Programmatically select rows by ID\r\n   * @param {String|Array} rowIds - Single row ID or array of row IDs\r\n   */\r\n  selectRows(rowIds) {\r\n    if (!this.options.enabled) {\r\n      return;\r\n    }\r\n\r\n    const ids = Array.isArray(rowIds) ? rowIds : [rowIds];\r\n    \r\n    if (this.options.mode === 'single' && ids.length > 1) {\r\n      console.warn('SelectionManager: Cannot select multiple rows in single mode');\r\n      return;\r\n    }\r\n\r\n    if (this.options.mode === 'single') {\r\n      this.selectedRows.clear();\r\n    }\r\n\r\n    ids.forEach(id => {\r\n      this.selectedRows.add(String(id));\r\n    });\r\n\r\n    if (ids.length > 0) {\r\n      this.lastSelectedRow = String(ids[ids.length - 1]);\r\n    }\r\n\r\n    this.updateUI();\r\n    \r\n    // Fire afterSelect event\r\n    this.table.eventManager.trigger('afterSelect', {\r\n      selectedRows: Array.from(this.selectedRows),\r\n      selectedData: this.getSelectedData()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Programmatically deselect rows by ID\r\n   * @param {String|Array} rowIds - Single row ID or array of row IDs\r\n   */\r\n  deselectRows(rowIds) {\r\n    if (!this.options.enabled) {\r\n      return;\r\n    }\r\n\r\n    const ids = Array.isArray(rowIds) ? rowIds : [rowIds];\r\n    \r\n    ids.forEach(id => {\r\n      this.selectedRows.delete(String(id));\r\n    });\r\n\r\n    // Update last selected row if it was deselected\r\n    if (ids.includes(this.lastSelectedRow)) {\r\n      this.lastSelectedRow = this.selectedRows.size > 0 ? Array.from(this.selectedRows)[0] : null;\r\n    }\r\n\r\n    this.updateUI();\r\n    \r\n    // Fire afterSelect event\r\n    this.table.eventManager.trigger('afterSelect', {\r\n      selectedRows: Array.from(this.selectedRows),\r\n      selectedData: this.getSelectedData()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clear all selections\r\n   */\r\n  clearSelection() {\r\n    if (!this.options.enabled) {\r\n      return;\r\n    }\r\n\r\n    const hadSelection = this.selectedRows.size > 0;\r\n    this.selectedRows.clear();\r\n    this.lastSelectedRow = null;\r\n    \r\n    this.updateUI();\r\n\r\n    if (hadSelection) {\r\n      // Fire afterSelect event\r\n      this.table.eventManager.trigger('afterSelect', {\r\n        selectedRows: [],\r\n        selectedData: []\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a row is selected\r\n   * @param {String} rowId - Row ID to check\r\n   * @returns {Boolean} True if row is selected\r\n   */\r\n  isRowSelected(rowId) {\r\n    return this.selectedRows.has(String(rowId));\r\n  }\r\n\r\n  /**\r\n   * Check if a row is selected by its data object (for virtual scrolling)\r\n   * @param {Object} rowData - Row data object to check\r\n   * @returns {Boolean} True if row is selected\r\n   */\r\n  isRowSelectedByData(rowData) {\r\n    const rowId = this.getRowId(rowData);\r\n    return this.selectedRows.has(String(rowId));\r\n  }\r\n\r\n  /**\r\n   * Get selection count\r\n   * @returns {Number} Number of selected rows\r\n   */\r\n  getSelectionCount() {\r\n    return this.selectedRows.size;\r\n  }\r\n\r\n  /**\r\n   * Enable selection\r\n   */\r\n  enable() {\r\n    this.options.enabled = true;\r\n    if (!this.eventListenersSetup) {\r\n      this.setupEventListeners();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disable selection\r\n   */\r\n  disable() {\r\n    this.options.enabled = false;\r\n    this.clearSelection();\r\n  }\r\n\r\n  /**\r\n   * Set selection mode\r\n   * @param {String} mode - 'single' or 'multi'\r\n   */\r\n  setMode(mode) {\r\n    if (mode !== 'single' && mode !== 'multi') {\r\n      console.warn('SelectionManager: Invalid mode. Use \"single\" or \"multi\"');\r\n      return;\r\n    }\r\n\r\n    const oldMode = this.options.mode;\r\n    this.options.mode = mode;\r\n    \r\n    // If switching to single mode and multiple rows are selected, keep only the last selected\r\n    if (mode === 'single' && this.selectedRows.size > 1) {\r\n      const lastSelected = this.lastSelectedRow;\r\n      this.selectedRows.clear();\r\n      if (lastSelected) {\r\n        this.selectedRows.add(lastSelected);\r\n      }\r\n      this.updateUI();\r\n    }\r\n\r\n    // Setup or remove drag selection based on mode change\r\n    if (oldMode !== mode && this.options.enabled) {\r\n      if (mode === 'multi') {\r\n        this.setupDragSelection();\r\n      }\r\n      // Note: We don't need to explicitly remove drag listeners as they check mode internally\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy the selection manager\r\n   */\r\n  destroy() {\r\n    this.clearSelection();\r\n    // Remove event listeners would go here if we tracked them\r\n  }\r\n}\r\n","/**\r\n * VirtualScrollManager - High-performance virtual scrolling for large datasets\r\n * \r\n * Features:\r\n * - Dynamic row height detection\r\n * - Configurable buffer zones\r\n * - Smooth scrolling with no visual gaps\r\n * - Selection state preservation\r\n * - Performance optimizations for 100k+ rows\r\n */\r\nexport default class VirtualScrollManager {\r\n  constructor(table, options = {}) {\r\n    this.table = table;\r\n    this.options = {\r\n      enabled: false,\r\n      buffer: 10, // Number of rows to render above/below viewport\r\n      rowHeight: null, // Auto-detected if null\r\n      throttleDelay: 8, // Reduced from 16ms for better responsiveness (~120fps)\r\n      ...options\r\n    };\r\n\r\n    // State tracking\r\n    this.scrollContainer = null;\r\n    this.tableBody = null;\r\n    this.topSpacer = null;\r\n    this.bottomSpacer = null;\r\n    \r\n    // Measurements\r\n    this.rowHeight = this.options.rowHeight || 35; // Default fallback\r\n    this.containerHeight = 0;\r\n    this.totalRows = 0;\r\n    this.visibleStart = 0;\r\n    this.visibleEnd = 0;\r\n    this.renderedStart = 0;\r\n    this.renderedEnd = 0;\r\n    \r\n    // Performance tracking\r\n    this.performanceData = {\r\n      renderTimes: [],\r\n      scrollUpdates: 0,\r\n      lastMeasurement: 0\r\n    };\r\n\r\n    // Throttled scroll handler\r\n    this.throttledScrollHandler = this.throttle(this.handleScroll.bind(this), this.options.throttleDelay);\r\n    this.immediateScrollHandler = this.handleScroll.bind(this);\r\n    \r\n    // RAF-based update handler for smooth rendering\r\n    this.updateScheduled = false;\r\n    this.pendingUpdate = false;\r\n    this.lastScrollTime = 0;\r\n    this.scrollVelocity = 0;\r\n\r\n    // Data reference\r\n    this.data = [];\r\n    this.renderedData = [];\r\n  }\r\n\r\n  /**\r\n   * Initialize virtual scrolling\r\n   */\r\n  init(data = []) {\r\n    if (!this.options.enabled) {\r\n      return;\r\n    }\r\n\r\n    this.data = data;\r\n    this.totalRows = data.length;\r\n    \r\n    this.setupScrollContainer();\r\n    this.detectRowHeight();\r\n    this.calculateViewport();\r\n    this.scheduleUpdate();\r\n    \r\n    // Bind scroll events with both throttled and immediate handling\r\n    this.scrollContainer.addEventListener('scroll', this.handleScrollImmediate.bind(this), { passive: true });\r\n    this.scrollContainer.addEventListener('scroll', this.throttledScrollHandler, { passive: true });\r\n    \r\n    // Handle scrollbar dragging specifically\r\n    this.scrollContainer.addEventListener('mousedown', this.handleScrollStart.bind(this));\r\n    document.addEventListener('mouseup', this.handleScrollEnd.bind(this));\r\n    \r\n    // Handle window resize\r\n    window.addEventListener('resize', this.throttle(this.handleResize.bind(this), 100));\r\n    \r\n    // Set up event delegation for row interactions\r\n    this.setupEventDelegation();\r\n    \r\n    // Listen for selection changes\r\n    this.setupSelectionListeners();\r\n    \r\n    this.log('Virtual scroll initialized', {\r\n      totalRows: this.totalRows,\r\n      rowHeight: this.rowHeight,\r\n      buffer: this.options.buffer\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set up event delegation for dynamically rendered rows\r\n   */\r\n  setupEventDelegation() {\r\n    if (!this.scrollContainer || !this.table.eventManager) return;\r\n\r\n    // Delegate row click events\r\n    this.rowClickHandler = (event) => {\r\n      const row = event.target.closest('.tablix-row');\r\n      if (!row) return;\r\n\r\n      // Skip click handling if we just finished a drag\r\n      if (this.justFinishedDrag) {\r\n        console.log('Skipping click - just finished drag');\r\n        return;\r\n      }\r\n\r\n      const virtualIndex = parseInt(row.getAttribute('data-virtual-index'));\r\n      const rowData = this.data[virtualIndex];\r\n      \r\n      if (rowData) {\r\n        console.log('VirtualScroll rowClickHandler triggered:', { \r\n          virtualIndex, \r\n          rowId: rowData.id,\r\n          ctrlKey: event.ctrlKey,\r\n          shiftKey: event.shiftKey,\r\n          metaKey: event.metaKey,\r\n          eventType: event.type,\r\n          timestamp: Date.now()\r\n        });\r\n        \r\n        // Trigger row click event for selection manager\r\n        this.table.eventManager.trigger('rowClick', {\r\n          rowData,\r\n          rowIndex: virtualIndex, // Use virtual index as row index\r\n          originalEvent: event,\r\n          element: row\r\n        });\r\n        \r\n        // Immediately update selection states after click\r\n        setTimeout(() => this.updateSelectionStates(), 0);\r\n      }\r\n    };\r\n\r\n    this.scrollContainer.addEventListener('click', this.rowClickHandler);\r\n\r\n    // Set up drag selection for virtual scrolling (if selection is enabled and in multi mode)\r\n    if (this.table.selectionManager && \r\n        this.table.selectionManager.options.enabled && \r\n        this.table.selectionManager.options.mode === 'multi') {\r\n      this.setupVirtualDragSelection();\r\n    }\r\n\r\n    // Delegate row hover events\r\n    this.rowHoverHandler = (event) => {\r\n      const row = event.target.closest('.tablix-row');\r\n      if (!row) return;\r\n\r\n      const virtualIndex = parseInt(row.getAttribute('data-virtual-index'));\r\n      const rowData = this.data[virtualIndex];\r\n      \r\n      if (rowData) {\r\n        this.table.eventManager.trigger('rowHover', {\r\n          rowData,\r\n          rowIndex: virtualIndex,\r\n          originalEvent: event,\r\n          element: row\r\n        });\r\n      }\r\n    };\r\n\r\n    this.scrollContainer.addEventListener('mouseover', this.rowHoverHandler);\r\n  }\r\n\r\n  /**\r\n   * Set up listeners for selection changes\r\n   */\r\n  setupSelectionListeners() {\r\n    if (!this.table.eventManager) return;\r\n\r\n    // Listen for selection changes to update row visual states\r\n    this.table.eventManager.on('afterSelect', () => {\r\n      this.updateSelectionStates();\r\n    });\r\n\r\n    this.table.eventManager.on('selectionCleared', () => {\r\n      this.updateSelectionStates();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Setup the scroll container structure\r\n   */\r\n  setupScrollContainer() {\r\n    const tableWrapper = this.table.container.querySelector('.tablix-wrapper');\r\n    if (!tableWrapper) {\r\n      throw new Error('Table wrapper not found for virtual scrolling');\r\n    }\r\n\r\n    // Find existing scroll container\r\n    let scrollContainer = tableWrapper.querySelector('.tablix-scroll-container');\r\n    if (!scrollContainer) {\r\n      // Create scroll container - it should already exist from renderer\r\n      scrollContainer = tableWrapper.querySelector('.tablix-scroll-container');\r\n      if (!scrollContainer) {\r\n        console.warn('Scroll container not found - virtual scrolling may not work properly');\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.scrollContainer = scrollContainer;\r\n    this.tableBody = scrollContainer.querySelector('.tablix-tbody');\r\n    \r\n    // Create spacer elements for maintaining scroll height\r\n    this.createSpacers();\r\n  }\r\n\r\n  /**\r\n   * Create top and bottom spacer elements\r\n   */\r\n  createSpacers() {\r\n    if (!this.tableBody) return;\r\n\r\n    // Remove existing spacers\r\n    const existingTop = this.tableBody.querySelector('.tablix-top-spacer');\r\n    const existingBottom = this.tableBody.querySelector('.tablix-bottom-spacer');\r\n    if (existingTop) existingTop.remove();\r\n    if (existingBottom) existingBottom.remove();\r\n\r\n    // Create new spacers\r\n    this.topSpacer = document.createElement('tr');\r\n    this.topSpacer.className = 'tablix-top-spacer';\r\n    this.topSpacer.style.cssText = 'height: 0px; border: none;';\r\n    this.topSpacer.innerHTML = `<td colspan=\"100\" style=\"padding: 0; border: none; height: 0;\"></td>`;\r\n\r\n    this.bottomSpacer = document.createElement('tr');\r\n    this.bottomSpacer.className = 'tablix-bottom-spacer';\r\n    this.bottomSpacer.style.cssText = 'height: 0px; border: none;';\r\n    this.bottomSpacer.innerHTML = `<td colspan=\"100\" style=\"padding: 0; border: none; height: 0;\"></td>`;\r\n\r\n    this.tableBody.insertBefore(this.topSpacer, this.tableBody.firstChild);\r\n    this.tableBody.appendChild(this.bottomSpacer);\r\n  }\r\n\r\n  /**\r\n   * Detect row height dynamically by measuring a sample row\r\n   */\r\n  detectRowHeight() {\r\n    if (this.options.rowHeight) {\r\n      this.rowHeight = this.options.rowHeight;\r\n      return;\r\n    }\r\n\r\n    if (!this.tableBody || this.data.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Render a single sample row to measure height\r\n    const sampleRow = this.renderSingleRow(this.data[0], 0);\r\n    this.tableBody.appendChild(sampleRow);\r\n    \r\n    // Measure the row height\r\n    const rect = sampleRow.getBoundingClientRect();\r\n    this.rowHeight = Math.max(rect.height, 25); // Minimum height of 25px\r\n    \r\n    // Remove sample row\r\n    sampleRow.remove();\r\n    \r\n    this.log('Row height detected', { rowHeight: this.rowHeight });\r\n  }\r\n\r\n  /**\r\n   * Calculate viewport dimensions and visible range\r\n   */\r\n  calculateViewport() {\r\n    if (!this.scrollContainer) return;\r\n\r\n    const rect = this.scrollContainer.getBoundingClientRect();\r\n    this.containerHeight = rect.height;\r\n    \r\n    const scrollTop = this.scrollContainer.scrollTop;\r\n    const visibleRowCount = Math.ceil(this.containerHeight / this.rowHeight);\r\n    \r\n    // Calculate visible range\r\n    this.visibleStart = Math.floor(scrollTop / this.rowHeight);\r\n    this.visibleEnd = Math.min(this.visibleStart + visibleRowCount, this.totalRows);\r\n    \r\n    // Calculate rendered range with buffer\r\n    this.renderedStart = Math.max(0, this.visibleStart - this.options.buffer);\r\n    this.renderedEnd = Math.min(this.totalRows, this.visibleEnd + this.options.buffer);\r\n    \r\n    // Update spacer heights\r\n    this.updateSpacers();\r\n  }\r\n\r\n  /**\r\n   * Update spacer heights to maintain scroll position\r\n   */\r\n  updateSpacers() {\r\n    if (!this.topSpacer || !this.bottomSpacer) return;\r\n\r\n    const topHeight = this.renderedStart * this.rowHeight;\r\n    const bottomHeight = (this.totalRows - this.renderedEnd) * this.rowHeight;\r\n    \r\n    this.topSpacer.style.height = `${topHeight}px`;\r\n    this.bottomSpacer.style.height = `${bottomHeight}px`;\r\n  }\r\n\r\n  /**\r\n   * Handle immediate scroll events (for fast scrolling detection)\r\n   */\r\n  handleScrollImmediate() {\r\n    const now = performance.now();\r\n    const scrollTop = this.scrollContainer.scrollTop;\r\n    \r\n    // Calculate scroll velocity\r\n    if (this.lastScrollTime && this.lastScrollTop !== undefined) {\r\n      const timeDelta = now - this.lastScrollTime;\r\n      const scrollDelta = Math.abs(scrollTop - this.lastScrollTop);\r\n      this.scrollVelocity = timeDelta > 0 ? scrollDelta / timeDelta : 0;\r\n    }\r\n    \r\n    this.lastScrollTime = now;\r\n    this.lastScrollTop = scrollTop;\r\n    \r\n    // For very fast scrolling, schedule immediate update\r\n    if (this.scrollVelocity > 2) { // High velocity threshold\r\n      this.scheduleUpdate();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle scroll start (mousedown on scrollbar)\r\n   */\r\n  handleScrollStart(event) {\r\n    // Only trigger scrollbar dragging for actual scrollbar clicks\r\n    // Check if the click was on the scrollbar area, not on table content\r\n    const target = event.target;\r\n    if (target.closest('.tablix-row') || target.closest('.tablix-table')) {\r\n      // This is a click on table content, not scrollbar - ignore\r\n      return;\r\n    }\r\n    \r\n    this.isScrollbarDragging = true;\r\n    \r\n    // Schedule more frequent updates during scrollbar dragging\r\n    this.scrollDragInterval = setInterval(() => {\r\n      if (this.isScrollbarDragging) {\r\n        this.scheduleUpdate();\r\n      }\r\n    }, 8); // ~120fps during dragging\r\n  }\r\n\r\n  /**\r\n   * Handle scroll end (mouseup)\r\n   */\r\n  handleScrollEnd() {\r\n    this.isScrollbarDragging = false;\r\n    if (this.scrollDragInterval) {\r\n      clearInterval(this.scrollDragInterval);\r\n      this.scrollDragInterval = null;\r\n    }\r\n    // Final update to ensure everything is rendered\r\n    this.scheduleUpdate();\r\n  }\r\n\r\n  /**\r\n   * Setup drag selection for virtual scrolling\r\n   */\r\n  setupVirtualDragSelection() {\r\n    let isDragSelecting = false;\r\n    let dragStartIndex = null;\r\n    let dragStartX = null;\r\n    let dragStartY = null;\r\n    let originalSelection = null;\r\n    const dragThreshold = 3;\r\n\r\n    // Flag to prevent click handling immediately after drag\r\n    this.justFinishedDrag = false;\r\n\r\n    // Mouse down to potentially start drag selection\r\n    this.scrollContainer.addEventListener('mousedown', (event) => {\r\n      // Skip if clicked on scrollbar area or using modifier keys\r\n      if (event.ctrlKey || event.metaKey || event.shiftKey) return;\r\n      \r\n      const row = event.target.closest('.tablix-row');\r\n      if (!row || row.classList.contains('tablix-empty-row')) return;\r\n\r\n      const virtualIndex = parseInt(row.getAttribute('data-virtual-index'));\r\n      if (isNaN(virtualIndex)) return;\r\n\r\n      dragStartIndex = virtualIndex;\r\n      dragStartX = event.clientX;\r\n      dragStartY = event.clientY;\r\n      isDragSelecting = false;\r\n      \r\n      // Store original selection\r\n      originalSelection = new Set(this.table.selectionManager.selectedRows);\r\n\r\n      // Don't prevent default here - let the click event fire normally\r\n      // event.preventDefault();\r\n    });\r\n\r\n    // Mouse move to handle drag selection\r\n    this.scrollContainer.addEventListener('mousemove', (event) => {\r\n      if (dragStartIndex === null) return;\r\n\r\n      const deltaX = Math.abs(event.clientX - dragStartX);\r\n      const deltaY = Math.abs(event.clientY - dragStartY);\r\n\r\n      // Start dragging if moved enough\r\n      if (!isDragSelecting && (deltaX > dragThreshold || deltaY > dragThreshold)) {\r\n        isDragSelecting = true;\r\n        this.scrollContainer.classList.add('tablix-drag-selecting');\r\n      }\r\n\r\n      if (isDragSelecting) {\r\n        const row = event.target.closest('.tablix-row');\r\n        if (row) {\r\n          const currentIndex = parseInt(row.getAttribute('data-virtual-index'));\r\n          if (!isNaN(currentIndex)) {\r\n            this.applyVirtualDragSelection(dragStartIndex, currentIndex, originalSelection);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Mouse up to complete or cancel drag selection\r\n    const handleMouseUp = (event) => {\r\n      if (dragStartIndex !== null) {\r\n        this.scrollContainer.classList.remove('tablix-drag-selecting');\r\n        \r\n        if (!isDragSelecting) {\r\n          // This was just a click, not a drag - don't interfere with click handling\r\n          // Reset drag state and let the normal click handler process this\r\n          dragStartIndex = null;\r\n          isDragSelecting = false;\r\n          originalSelection = null;\r\n          return;\r\n        }\r\n\r\n        // This was actually a drag selection - complete it\r\n        this.table.eventManager.trigger('afterSelect', {\r\n          selectedRows: Array.from(this.table.selectionManager.selectedRows),\r\n          selectedData: this.table.selectionManager.getSelectedData(),\r\n          isDragSelection: true,\r\n          dragComplete: true\r\n        });\r\n\r\n        // Set flag to prevent immediate click handling\r\n        this.justFinishedDrag = true;\r\n        setTimeout(() => {\r\n          this.justFinishedDrag = false;\r\n        }, 50);\r\n\r\n        // Reset drag state\r\n        dragStartIndex = null;\r\n        isDragSelecting = false;\r\n        originalSelection = null;\r\n      }\r\n    };\r\n\r\n    document.addEventListener('mouseup', handleMouseUp);\r\n    this.scrollContainer.addEventListener('mouseleave', handleMouseUp);\r\n\r\n    // Prevent text selection during drag\r\n    this.scrollContainer.addEventListener('selectstart', (event) => {\r\n      if (isDragSelecting) {\r\n        event.preventDefault();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Apply drag selection in virtual scrolling\r\n   */\r\n  applyVirtualDragSelection(startIndex, endIndex, originalSelection) {\r\n    const minIndex = Math.min(startIndex, endIndex);\r\n    const maxIndex = Math.max(startIndex, endIndex);\r\n\r\n    // Start with original selection\r\n    this.table.selectionManager.selectedRows = new Set(originalSelection);\r\n\r\n    // Add drag range to selection\r\n    for (let i = minIndex; i <= maxIndex; i++) {\r\n      if (i < this.data.length) {\r\n        const rowData = this.data[i];\r\n        const rowId = this.table.selectionManager.getRowId(rowData);\r\n        this.table.selectionManager.selectedRows.add(rowId);\r\n      }\r\n    }\r\n\r\n    // Update last selected row\r\n    if (endIndex < this.data.length) {\r\n      const endRowData = this.data[endIndex];\r\n      this.table.selectionManager.lastSelectedRow = this.table.selectionManager.getRowId(endRowData);\r\n    }\r\n\r\n    // Update UI immediately\r\n    this.table.selectionManager.updateUI();\r\n  }\r\n\r\n  /**\r\n   * Handle scroll events\r\n   */\r\n  handleScroll() {\r\n    if (!this.options.enabled || this.updateScheduled) return;\r\n\r\n    this.scheduleUpdate();\r\n  }\r\n\r\n  /**\r\n   * Handle window resize\r\n   */\r\n  handleResize() {\r\n    if (!this.options.enabled) return;\r\n\r\n    this.calculateViewport();\r\n    this.scheduleUpdate();\r\n  }\r\n\r\n  /**\r\n   * Schedule an update using requestAnimationFrame\r\n   */\r\n  scheduleUpdate() {\r\n    if (this.updateScheduled) return;\r\n\r\n    this.updateScheduled = true;\r\n    requestAnimationFrame(() => {\r\n      this.update();\r\n      this.updateScheduled = false;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Main update method - calculates viewport and renders visible rows\r\n   */\r\n  update() {\r\n    const startTime = performance.now();\r\n    \r\n    this.calculateViewport();\r\n    this.renderVisibleRows();\r\n    \r\n    const endTime = performance.now();\r\n    this.trackPerformance(endTime - startTime);\r\n    \r\n    this.performanceData.scrollUpdates++;\r\n  }\r\n\r\n  /**\r\n   * Render only the visible rows plus buffer\r\n   */\r\n  renderVisibleRows() {\r\n    if (!this.tableBody) return;\r\n\r\n    // Clear existing rows (except spacers)\r\n    const existingRows = this.tableBody.querySelectorAll('.tablix-row');\r\n    existingRows.forEach(row => row.remove());\r\n\r\n    // Render new rows\r\n    const fragment = document.createDocumentFragment();\r\n    \r\n    for (let i = this.renderedStart; i < this.renderedEnd; i++) {\r\n      if (i < this.data.length) {\r\n        const row = this.renderSingleRow(this.data[i], i);\r\n        fragment.appendChild(row);\r\n      }\r\n    }\r\n\r\n    // Insert rows between spacers\r\n    this.tableBody.insertBefore(fragment, this.bottomSpacer);\r\n\r\n    // Store currently rendered data slice for other managers\r\n    this.renderedData = this.data.slice(this.renderedStart, this.renderedEnd);\r\n    \r\n    // Handle image loading for the newly rendered rows\r\n    this.handleImageLoading();\r\n    \r\n    // Update selection states for the newly rendered rows\r\n    this.updateSelectionStates();\r\n  }\r\n\r\n  /**\r\n   * Update selection states for currently rendered rows\r\n   */\r\n  updateSelectionStates() {\r\n    if (!this.table.selectionManager || !this.tableBody) return;\r\n\r\n    const rows = this.tableBody.querySelectorAll('.tablix-row');\r\n    rows.forEach(row => {\r\n      const virtualIndex = parseInt(row.getAttribute('data-virtual-index'));\r\n      const rowData = this.data[virtualIndex];\r\n      \r\n      if (rowData && this.table.selectionManager.isRowSelectedByData(rowData)) {\r\n        row.classList.add('tablix-selected');\r\n      } else {\r\n        row.classList.remove('tablix-selected');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle image loading optimization\r\n   */\r\n  handleImageLoading() {\r\n    if (!this.tableBody) return;\r\n\r\n    // Find all images in the rendered rows\r\n    const images = this.tableBody.querySelectorAll('.tablix-row img');\r\n    \r\n    images.forEach((img, index) => {\r\n      // Skip if image is already loaded or loading\r\n      if (img.complete || img.classList.contains('loading')) return;\r\n      \r\n      img.classList.add('loading');\r\n      \r\n      // Create a placeholder while loading\r\n      const placeholder = img.cloneNode();\r\n      placeholder.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiBmaWxsPSIjZjBmMGYwIi8+CjxwYXRoIGQ9Ik0xNiA4TDIwIDEySDEyTDE2IDhaIiBmaWxsPSIjY2NjY2NjIi8+CjxwYXRoIGQ9Ik04IDIwSDI0VjE2SDhWMjBaIiBmaWxsPSIjY2NjY2NjIi8+Cjwvc3ZnPgo=';\r\n      placeholder.classList.add('image-placeholder');\r\n      \r\n      // Handle successful load\r\n      const handleLoad = () => {\r\n        img.classList.remove('loading');\r\n        img.style.opacity = '1';\r\n        img.removeEventListener('load', handleLoad);\r\n        img.removeEventListener('error', handleError);\r\n      };\r\n      \r\n      // Handle load error\r\n      const handleError = () => {\r\n        img.classList.remove('loading');\r\n        img.src = placeholder.src; // Use placeholder as fallback\r\n        img.removeEventListener('load', handleLoad);\r\n        img.removeEventListener('error', handleError);\r\n      };\r\n      \r\n      img.addEventListener('load', handleLoad);\r\n      img.addEventListener('error', handleError);\r\n      \r\n      // Set initial opacity for fade-in effect\r\n      img.style.opacity = '0.5';\r\n      img.style.transition = 'opacity 0.2s ease';\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Render a single row element\r\n   */\r\n  renderSingleRow(rowData, originalIndex) {\r\n    const columns = this.table.columnManager ? \r\n      this.table.columnManager.getColumns() : \r\n      (this.table.options.columns || []);\r\n\r\n    const tr = document.createElement('tr');\r\n    tr.className = 'tablix-row';\r\n    tr.setAttribute('data-row-index', originalIndex); // Keep for compatibility\r\n    tr.setAttribute('data-virtual-index', originalIndex); // Virtual scroll index\r\n    \r\n    // Add a unique identifier for debugging\r\n    tr.setAttribute('data-row-id', this.table.selectionManager ? \r\n      this.table.selectionManager.getRowId(rowData) : originalIndex);\r\n\r\n    // Apply initial selection state\r\n    const isSelected = this.table.selectionManager && \r\n      this.table.selectionManager.isRowSelectedByData(rowData);\r\n    \r\n    if (isSelected) {\r\n      tr.classList.add('tablix-selected');\r\n      console.log('Row initially selected:', originalIndex, rowData.id);\r\n    }\r\n\r\n    // Render cells\r\n    columns.forEach(col => {\r\n      const td = document.createElement('td');\r\n      td.className = 'tablix-td';\r\n      \r\n      const cellValue = rowData[col.name];\r\n\r\n      // Use ColumnManager for formatting if available\r\n      if (this.table.columnManager) {\r\n        const result = this.table.columnManager.formatCellValue(col.name, cellValue, rowData);\r\n        if (result.isHtml) {\r\n          td.innerHTML = result.value;\r\n        } else {\r\n          td.textContent = result.value;\r\n        }\r\n      } else {\r\n        // Fallback to original renderer logic\r\n        if (col.renderer && typeof col.renderer === 'function') {\r\n          const rendered = col.renderer(cellValue, rowData);\r\n          if (typeof rendered === 'string' && rendered.includes('<')) {\r\n            td.innerHTML = rendered;\r\n          } else {\r\n            td.textContent = rendered;\r\n          }\r\n        } else {\r\n          td.textContent = cellValue != null ? String(cellValue) : '';\r\n        }\r\n      }\r\n\r\n      tr.appendChild(td);\r\n    });\r\n\r\n    return tr;\r\n  }\r\n\r\n  /**\r\n   * Update data and refresh virtual scrolling\r\n   */\r\n  updateData(newData) {\r\n    this.data = newData;\r\n    this.totalRows = newData.length;\r\n    \r\n    if (this.options.enabled) {\r\n      this.calculateViewport();\r\n      this.scheduleUpdate();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scroll to a specific row index\r\n   */\r\n  scrollToRow(index) {\r\n    if (!this.scrollContainer || !this.options.enabled) return;\r\n\r\n    const targetScrollTop = index * this.rowHeight;\r\n    this.scrollContainer.scrollTop = targetScrollTop;\r\n    \r\n    // Force immediate update\r\n    this.update();\r\n  }\r\n\r\n  /**\r\n   * Get the currently visible row indices\r\n   */\r\n  getVisibleRange() {\r\n    return {\r\n      start: this.visibleStart,\r\n      end: this.visibleEnd,\r\n      renderedStart: this.renderedStart,\r\n      renderedEnd: this.renderedEnd\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get the currently rendered data slice\r\n   */\r\n  getRenderedData() {\r\n    return this.renderedData;\r\n  }\r\n\r\n  /**\r\n   * Check if virtual scrolling is active\r\n   */\r\n  isEnabled() {\r\n    return this.options.enabled;\r\n  }\r\n\r\n  /**\r\n   * Enable/disable virtual scrolling\r\n   */\r\n  setEnabled(enabled) {\r\n    this.options.enabled = enabled;\r\n    \r\n    if (enabled && this.data.length > 0) {\r\n      this.init(this.data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track performance metrics\r\n   */\r\n  trackPerformance(renderTime) {\r\n    this.performanceData.renderTimes.push(renderTime);\r\n    this.performanceData.lastMeasurement = renderTime;\r\n\r\n    // Keep only last 100 measurements\r\n    if (this.performanceData.renderTimes.length > 100) {\r\n      this.performanceData.renderTimes.shift();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get performance statistics\r\n   */\r\n  getPerformanceStats() {\r\n    const times = this.performanceData.renderTimes;\r\n    if (times.length === 0) return null;\r\n\r\n    const avg = times.reduce((a, b) => a + b, 0) / times.length;\r\n    const max = Math.max(...times);\r\n    const min = Math.min(...times);\r\n\r\n    return {\r\n      averageRenderTime: avg.toFixed(2),\r\n      maxRenderTime: max.toFixed(2),\r\n      minRenderTime: min.toFixed(2),\r\n      scrollUpdates: this.performanceData.scrollUpdates,\r\n      totalRows: this.totalRows,\r\n      visibleRows: this.visibleEnd - this.visibleStart,\r\n      renderedRows: this.renderedEnd - this.renderedStart\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Utility: Throttle function\r\n   */\r\n  throttle(func, limit) {\r\n    let inThrottle;\r\n    return function() {\r\n      const args = arguments;\r\n      const context = this;\r\n      if (!inThrottle) {\r\n        func.apply(context, args);\r\n        inThrottle = true;\r\n        setTimeout(() => inThrottle = false, limit);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Utility: Logging for performance tracking\r\n   */\r\n  log(message, data = {}) {\r\n    if (this.table.options.debug) {\r\n      console.log(`[VirtualScroll] ${message}`, data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up event listeners and resources\r\n   */\r\n  destroy() {\r\n    if (this.scrollContainer) {\r\n      this.scrollContainer.removeEventListener('scroll', this.throttledScrollHandler);\r\n      this.scrollContainer.removeEventListener('scroll', this.handleScrollImmediate);\r\n      this.scrollContainer.removeEventListener('mousedown', this.handleScrollStart);\r\n    }\r\n    document.removeEventListener('mouseup', this.handleScrollEnd);\r\n    window.removeEventListener('resize', this.handleResize);\r\n    \r\n    // Clean up scroll drag interval\r\n    if (this.scrollDragInterval) {\r\n      clearInterval(this.scrollDragInterval);\r\n      this.scrollDragInterval = null;\r\n    }\r\n    \r\n    this.scrollContainer = null;\r\n    this.tableBody = null;\r\n    this.topSpacer = null;\r\n    this.bottomSpacer = null;\r\n  }\r\n}\r\n","import DataManager from './DataManager.js';\r\nimport Renderer from './Renderer.js';\r\nimport EventManager from './EventManager.js';\r\nimport PaginationManager from './PaginationManager.js';\r\nimport SortingManager from './SortingManager.js';\r\nimport ColumnManager from './ColumnManager.js';\r\nimport FilterManager from './FilterManager.js';\r\nimport FilterUI from './FilterUI.js';\r\nimport SearchManager from './SearchManager.js';\r\nimport SelectionManager from './SelectionManager.js';\r\nimport VirtualScrollManager from './VirtualScroll.js';\r\n\r\nexport default class Table {\r\n  constructor(container, options = {}) {\r\n    this.container = typeof container === 'string' ? document.querySelector(container) : container;\r\n    this.options = {\r\n      // Default options\r\n      pagination: {\r\n        enabled: true,\r\n        pageSize: 10,\r\n        mode: 'client', // 'client' or 'server'\r\n        showPageNumbers: true,\r\n        maxPageNumbers: 5,\r\n        showFirstLast: true,\r\n        showPrevNext: true,\r\n        showPageSizes: false,\r\n        pageSizeOptions: [10, 25, 50, 100],\r\n        serverDataLoader: null\r\n      },\r\n      // Sorting options\r\n      sorting: {\r\n        enabled: true,\r\n        mode: 'client', // 'client' or 'server'\r\n        serverSortLoader: null,\r\n        defaultSortType: 'auto',\r\n        caseSensitive: false,\r\n        nullsFirst: false\r\n      },\r\n      // Filtering options\r\n      filtering: {\r\n        enabled: true,\r\n        mode: 'client', // 'client' or 'server'\r\n        serverFilterLoader: null,\r\n        debounceDelay: 300,\r\n        showBadges: true,\r\n        showTooltips: true\r\n      },\r\n      // Control panels\r\n      controls: {\r\n        enabled: true,  // Enable by default to show search\r\n        search: true,\r\n        pagination: true,\r\n        pageSize: true,\r\n        refresh: true,\r\n        export: false,\r\n        position: 'top' // 'top', 'bottom', 'both'\r\n      },\r\n      search: {\r\n        enabled: true,\r\n        placeholder: 'Search...',\r\n        searchDelay: 300, // Debounce delay in milliseconds\r\n        minLength: 1, // Minimum characters before search starts\r\n        caseSensitive: false\r\n      },\r\n      // Selection options\r\n      selection: {\r\n        enabled: false,  // Default: selection is disabled\r\n        mode: 'single',  // 'single' or 'multi'\r\n        dataIdKey: 'id'  // Key to use as stable row identifier\r\n      },\r\n      // Virtual scrolling options\r\n      virtualScroll: {\r\n        enabled: false,\r\n        buffer: 10, // Number of rows to render above/below viewport\r\n        rowHeight: null, // Auto-detected if null\r\n        containerHeight: 400 // Default container height in pixels\r\n      },\r\n      ...options\r\n    };\r\n\r\n    // Initialize managers\r\n    this.eventManager = new EventManager();\r\n    this.columnManager = new ColumnManager(this);\r\n    this.dataManager = new DataManager(this, options.data || []);\r\n    this.renderer = new Renderer(this);\r\n    \r\n    // Initialize columns if provided\r\n    if (options.columns) {\r\n      this.columnManager.initializeColumns(options.columns);\r\n    }\r\n    \r\n    // Initialize pagination if enabled\r\n    if (this.options.pagination && this.options.pagination.enabled !== false) {\r\n      this.paginationManager = new PaginationManager(this, this.options.pagination);\r\n    }\r\n\r\n    // Initialize sorting if enabled\r\n    if (this.options.sorting && this.options.sorting.enabled !== false) {\r\n      this.sortingManager = new SortingManager(this, this.options.sorting);\r\n    }\r\n\r\n    // Initialize filtering if enabled\r\n    if (this.options.filtering && this.options.filtering.enabled !== false) {\r\n      this.filterManager = new FilterManager(this, this.options.filtering);\r\n      this.filterUI = new FilterUI(this.filterManager);\r\n    }\r\n\r\n    // Initialize search if enabled\r\n    if (this.options.search && this.options.search.enabled !== false) {\r\n      this.searchManager = new SearchManager(this, this.options.search);\r\n    }\r\n\r\n    // Initialize selection if enabled\r\n    if (this.options.selection) {\r\n      this.selectionManager = new SelectionManager(this, this.options.selection);\r\n    }\r\n\r\n    // Initialize virtual scrolling\r\n    if (this.options.virtualScroll) {\r\n      this.virtualScrollManager = new VirtualScrollManager(this, this.options.virtualScroll);\r\n    }\r\n\r\n    this.init();\r\n  }\r\n\r\n  async init() {\r\n    try {\r\n      // Initialize search manager\r\n      if (this.searchManager) {\r\n        this.searchManager.init();\r\n      }\r\n\r\n      // Get initial data\r\n      const initialData = this.dataManager.getData();\r\n      \r\n      // Trigger beforeLoad hook for initial data\r\n      this.eventManager.trigger('beforeLoad', { source: initialData });\r\n      \r\n      // Render table with first page of data\r\n      await this.refreshTable();\r\n      \r\n      // Trigger afterLoad hook with consistent payload format\r\n      this.eventManager.trigger('afterLoad', { data: initialData, source: initialData });\r\n    } catch (error) {\r\n      console.error('Failed to initialize table:', error);\r\n      this.eventManager.trigger('loadError', { error, source: 'initialization' });\r\n      if (this.renderer && this.renderer.renderError) {\r\n        this.renderer.renderError(error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Refresh the table with current data and pagination\r\n   */\r\n  async refreshTable() {\r\n    let dataToRender;\r\n    \r\n    if (this.virtualScrollManager && this.virtualScrollManager.isEnabled()) {\r\n      // Virtual scrolling mode - get all data for virtual scrolling manager\r\n      dataToRender = this.dataManager.getData();\r\n      \r\n      // Initialize or update virtual scrolling with full dataset\r\n      this.virtualScrollManager.updateData(dataToRender);\r\n      \r\n      // Render the table structure first (without data rows)\r\n      this.renderer.renderTable([], true); // Pass empty array and virtualMode flag\r\n      \r\n      // Initialize virtual scrolling after table structure is ready\r\n      this.virtualScrollManager.init(dataToRender);\r\n    } else if (this.paginationManager) {\r\n      // Traditional pagination mode\r\n      dataToRender = await this.paginationManager.getPageData();\r\n      this.renderer.renderTable(dataToRender);\r\n    } else {\r\n      // No pagination, show all data (traditional mode)\r\n      dataToRender = this.dataManager.getData();\r\n      this.renderer.renderTable(dataToRender);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load new data into the table\r\n   * Supports multiple data sources:\r\n   * - Array: loadData([{id: 1, name: 'John'}])\r\n   * - URL string: loadData('/api/data')\r\n   * - Async function: loadData(() => fetch('/api/data').then(r => r.json()))\r\n   * @param {Array|string|Function} source - Data source\r\n   */\r\n  async loadData(source) {\r\n    try {\r\n      // Trigger beforeLoad hook\r\n      this.eventManager.trigger('beforeLoad', { source });\r\n\r\n      let data;\r\n\r\n      // Handle different data source types\r\n      if (Array.isArray(source)) {\r\n        // Direct array data\r\n        data = source;\r\n      } else if (typeof source === 'string') {\r\n        // URL string - fetch data\r\n        data = await this._fetchFromUrl(source);\r\n      } else if (typeof source === 'function') {\r\n        // Custom async function\r\n        data = await source();\r\n      } else {\r\n        throw new Error('Invalid data source. Expected array, URL string, or function.');\r\n      }\r\n\r\n      // Validate data\r\n      if (!Array.isArray(data)) {\r\n        throw new Error('Data source must resolve to an array.');\r\n      }\r\n\r\n      // Update data and refresh table\r\n      this.dataManager.setData(data);\r\n      await this.refreshTable();\r\n      \r\n      // Trigger afterLoad hook\r\n      this.eventManager.trigger('afterLoad', { data, source });\r\n\r\n    } catch (error) {\r\n      // Handle loading errors\r\n      console.error('Error loading data:', error);\r\n      this.eventManager.trigger('loadError', { error, source });\r\n      \r\n      // Render error state\r\n      if (this.renderer && this.renderer.renderError) {\r\n        this.renderer.renderError(error);\r\n      }\r\n      \r\n      // Re-throw for caller handling\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal method to fetch data from URL\r\n   * @private\r\n   */\r\n  async _fetchFromUrl(url) {\r\n    if (typeof fetch === 'undefined') {\r\n      throw new Error('fetch is not available. Please use a modern browser or provide a polyfill.');\r\n    }\r\n\r\n    const response = await fetch(url);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * Filter data by criteria\r\n   */\r\n  async filter(criteria) {\r\n    this.dataManager.applyFilter(criteria);\r\n    await this.refreshTable();\r\n    this.eventManager.trigger('afterFilter', criteria);\r\n  }\r\n\r\n  /**\r\n   * Sort data by column\r\n   * @param {string} columnName - Column to sort by\r\n   * @param {string|null} direction - 'asc', 'desc', or null (unsorted)\r\n   */\r\n  async sort(columnName, direction = 'asc') {\r\n    if (this.sortingManager) {\r\n      await this.sortingManager.sort(columnName, direction);\r\n    } else {\r\n      // Fallback to legacy sorting\r\n      this.dataManager.applySorting([{ column: columnName, direction }]);\r\n      await this.refreshTable();\r\n      this.eventManager.trigger('afterSort', [{ column: columnName, direction }]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggle sort for a column (handles click cycling)\r\n   */\r\n  async toggleSort(columnName) {\r\n    if (this.sortingManager) {\r\n      await this.sortingManager.toggleSort(columnName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all sorting\r\n   */\r\n  async clearSorting() {\r\n    if (this.sortingManager) {\r\n      await this.sortingManager.clearSorting();\r\n    } else {\r\n      // Fallback to legacy sorting\r\n      this.dataManager.clearSorting();\r\n      await this.refreshTable();\r\n      this.eventManager.trigger('afterSort', []);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current sort state\r\n   */\r\n  getSortState() {\r\n    if (this.sortingManager) {\r\n      return this.sortingManager.getSortState();\r\n    }\r\n    return { sort: null, mode: 'client' };\r\n  }\r\n\r\n  /**\r\n   * Clear all filters\r\n   */\r\n  async clearFilters() {\r\n    this.dataManager.clearFilters();\r\n    await this.refreshTable();\r\n    this.eventManager.trigger('afterFilter', {});\r\n  }\r\n\r\n  /**\r\n   * Clear all sorting\r\n   */\r\n  async clearSorting() {\r\n    if (this.sortingManager) {\r\n      await this.sortingManager.clearSorting();\r\n    } else {\r\n      // Fallback to legacy sorting\r\n      this.dataManager.clearSorting();\r\n      await this.refreshTable();\r\n      this.eventManager.trigger('afterSort', []);\r\n    }\r\n  }\r\n\r\n  // ===== FILTERING API =====\r\n\r\n  /**\r\n   * Apply filter to a specific column\r\n   * @param {string} columnName - Column to filter\r\n   * @param {Object} filterConfig - Filter configuration\r\n   * @example\r\n   * table.applyFilter('status', { type: 'value', values: ['Active', 'Pending'] });\r\n   * table.applyFilter('name', { type: 'condition', conditions: [{ operator: 'beginsWith', value: 'A' }] });\r\n   */\r\n  async applyFilter(columnName, filterConfig) {\r\n    if (this.filterManager) {\r\n      await this.filterManager.applyFilter(columnName, filterConfig);\r\n    } else {\r\n      console.warn('TablixJS: Filtering is not enabled. Set filtering.enabled to true in options.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear filter for a specific column\r\n   * @param {string} columnName - Column to clear filter for\r\n   */\r\n  async clearFilter(columnName) {\r\n    if (this.filterManager) {\r\n      await this.filterManager.clearFilter(columnName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all filters\r\n   */\r\n  async clearAllFilters() {\r\n    if (this.filterManager) {\r\n      await this.filterManager.clearAllFilters();\r\n    } else {\r\n      // Fallback to legacy method\r\n      this.dataManager.clearFilters();\r\n      await this.refreshTable();\r\n      this.eventManager.trigger('afterFilter', {});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get active filters\r\n   * @returns {Object} Active filters by column\r\n   */\r\n  getActiveFilters() {\r\n    return this.filterManager ? this.filterManager.getActiveFilters() : {};\r\n  }\r\n\r\n  /**\r\n   * Get filter state for a column\r\n   * @param {string} columnName - Column name\r\n   * @returns {Object|null} Filter state\r\n   */\r\n  getColumnFilter(columnName) {\r\n    return this.filterManager ? this.filterManager.getColumnFilter(columnName) : null;\r\n  }\r\n\r\n  // ===== SEARCH API =====\r\n\r\n  /**\r\n   * Set search term programmatically\r\n   * @param {string} searchTerm - Search term\r\n   */\r\n  async setSearchTerm(searchTerm) {\r\n    if (this.searchManager) {\r\n      await this.searchManager.setSearchTerm(searchTerm);\r\n    } else {\r\n      console.warn('TablixJS: Search is not enabled. Set search.enabled to true in options.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current search term\r\n   * @returns {string} Current search term\r\n   */\r\n  getSearchTerm() {\r\n    return this.searchManager ? this.searchManager.getSearchTerm() : '';\r\n  }\r\n\r\n  /**\r\n   * Clear search\r\n   */\r\n  async clearSearch() {\r\n    if (this.searchManager) {\r\n      await this.searchManager.clearSearch();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get search information\r\n   * @returns {Object} Search results information\r\n   */\r\n  getSearchInfo() {\r\n    return this.searchManager ? this.searchManager.getSearchInfo() : null;\r\n  }\r\n\r\n  // ===== PAGINATION API =====\r\n\r\n  /**\r\n   * Go to next page\r\n   */\r\n  async nextPage() {\r\n    if (this.paginationManager) {\r\n      await this.paginationManager.nextPage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Go to previous page\r\n   */\r\n  async prevPage() {\r\n    if (this.paginationManager) {\r\n      await this.paginationManager.prevPage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Go to first page\r\n   */\r\n  async firstPage() {\r\n    if (this.paginationManager) {\r\n      await this.paginationManager.firstPage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Go to last page\r\n   */\r\n  async lastPage() {\r\n    if (this.paginationManager) {\r\n      await this.paginationManager.lastPage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Go to specific page\r\n   */\r\n  async goToPage(pageNumber) {\r\n    if (this.paginationManager) {\r\n      await this.paginationManager.goToPage(pageNumber);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Change page size\r\n   */\r\n  async changePageSize(pageSize) {\r\n    if (this.paginationManager) {\r\n      await this.paginationManager.changePageSize(pageSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pagination information\r\n   */\r\n  getPaginationInfo() {\r\n    return this.paginationManager ? this.paginationManager.getInfo() : null;\r\n  }\r\n\r\n  /**\r\n   * Enable/disable pagination\r\n   */\r\n  async setPaginationEnabled(enabled) {\r\n    if (this.paginationManager) {\r\n      this.paginationManager.setEnabled(enabled);\r\n      await this.refreshTable();\r\n    } else if (enabled) {\r\n      // Create pagination manager if it doesn't exist\r\n      this.paginationManager = new PaginationManager(this, this.options.pagination);\r\n      await this.refreshTable();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Switch between client-side and server-side pagination\r\n   */\r\n  async setPaginationMode(mode, serverDataLoader = null) {\r\n    if (this.paginationManager) {\r\n      await this.paginationManager.setMode(mode, serverDataLoader);\r\n    }\r\n  }\r\n\r\n  // ===== EVENT MANAGEMENT =====\r\n\r\n  /**\r\n   * Register event callback\r\n   */\r\n  on(event, callback) {\r\n    this.eventManager.on(event, callback);\r\n  }\r\n\r\n  /**\r\n   * Remove event callback\r\n   */\r\n  off(event, callback) {\r\n    this.eventManager.off(event, callback);\r\n  }\r\n\r\n  /**\r\n   * Clear event listeners\r\n   */\r\n  clearEvents(event) {\r\n    this.eventManager.clear(event);\r\n  }\r\n\r\n  /**\r\n   * Trigger event\r\n   */\r\n  trigger(event, data) {\r\n    this.eventManager.trigger(event, data);\r\n  }\r\n\r\n  // ===== UTILITY METHODS =====\r\n\r\n  /**\r\n   * Get current filtered data\r\n   */\r\n  getData() {\r\n    return this.dataManager.getData();\r\n  }\r\n\r\n  /**\r\n   * Get original unfiltered data\r\n   */\r\n  getOriginalData() {\r\n    return this.dataManager.originalData;\r\n  }\r\n\r\n  /**\r\n   * Get table options\r\n   */\r\n  getOptions() {\r\n    return this.options;\r\n  }\r\n\r\n  /**\r\n   * Update table options\r\n   */\r\n  async setOptions(newOptions) {\r\n    this.options = { ...this.options, ...newOptions };\r\n    \r\n    // Update pagination options if provided\r\n    if (newOptions.pagination && this.paginationManager) {\r\n      this.paginationManager.options = { ...this.paginationManager.options, ...newOptions.pagination };\r\n    }\r\n    \r\n    // Update selection options if provided\r\n    if (newOptions.selection && this.selectionManager) {\r\n      this.selectionManager.options = { ...this.selectionManager.options, ...newOptions.selection };\r\n      \r\n      // Re-initialize if enabled state changed\r\n      if (newOptions.selection.enabled !== undefined) {\r\n        if (newOptions.selection.enabled) {\r\n          this.selectionManager.enable();\r\n        } else {\r\n          this.selectionManager.disable();\r\n        }\r\n      }\r\n      \r\n      // Update mode if provided\r\n      if (newOptions.selection.mode) {\r\n        this.selectionManager.setMode(newOptions.selection.mode);\r\n      }\r\n    }\r\n    \r\n    await this.refreshTable();\r\n  }\r\n\r\n  // ===== SELECTION API =====\r\n\r\n  /**\r\n   * Get selected row data\r\n   * @returns {Array} Array of selected row data objects\r\n   */\r\n  getSelectedData() {\r\n    return this.selectionManager ? this.selectionManager.getSelectedData() : [];\r\n  }\r\n\r\n  /**\r\n   * Get selected row IDs\r\n   * @returns {Array} Array of selected row IDs\r\n   */\r\n  getSelectedIds() {\r\n    return this.selectionManager ? this.selectionManager.getSelectedIds() : [];\r\n  }\r\n\r\n  /**\r\n   * Programmatically select rows by ID\r\n   * @param {String|Array} rowIds - Single row ID or array of row IDs\r\n   */\r\n  selectRows(rowIds) {\r\n    if (this.selectionManager) {\r\n      this.selectionManager.selectRows(rowIds);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Programmatically deselect rows by ID\r\n   * @param {String|Array} rowIds - Single row ID or array of row IDs\r\n   */\r\n  deselectRows(rowIds) {\r\n    if (this.selectionManager) {\r\n      this.selectionManager.deselectRows(rowIds);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all selections\r\n   */\r\n  clearSelection() {\r\n    if (this.selectionManager) {\r\n      this.selectionManager.clearSelection();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a row is selected\r\n   * @param {String} rowId - Row ID to check\r\n   * @returns {Boolean} True if row is selected\r\n   */\r\n  isRowSelected(rowId) {\r\n    return this.selectionManager ? this.selectionManager.isRowSelected(rowId) : false;\r\n  }\r\n\r\n  /**\r\n   * Get selection count\r\n   * @returns {Number} Number of selected rows\r\n   */\r\n  getSelectionCount() {\r\n    return this.selectionManager ? this.selectionManager.getSelectionCount() : 0;\r\n  }\r\n\r\n  /**\r\n   * Enable selection\r\n   */\r\n  enableSelection() {\r\n    if (this.selectionManager) {\r\n      this.selectionManager.enable();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disable selection\r\n   */\r\n  disableSelection() {\r\n    if (this.selectionManager) {\r\n      this.selectionManager.disable();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set selection mode\r\n   * @param {String} mode - 'single' or 'multi'\r\n   */\r\n  setSelectionMode(mode) {\r\n    if (this.selectionManager) {\r\n      this.selectionManager.setMode(mode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Select all rows (currently visible/filtered rows)\r\n   * This will select all rows that are currently visible based on applied filters and search\r\n   * @returns {Number} Number of rows selected\r\n   */\r\n  selectAllRows() {\r\n    if (!this.selectionManager) {\r\n      console.warn('TablixJS: Selection is not enabled. Set selection.enabled to true in options.');\r\n      return 0;\r\n    }\r\n\r\n    // Get currently visible/filtered data\r\n    const allData = this.getData();\r\n    \r\n    if (allData.length === 0) {\r\n      console.warn('TablixJS: No rows available to select.');\r\n      return 0;\r\n    }\r\n\r\n    // Extract all IDs from current data\r\n    const dataIdKey = this.options.selection.dataIdKey || 'id';\r\n    const allIds = allData.map(row => String(row[dataIdKey]));\r\n\r\n    // Select all rows\r\n    this.selectionManager.selectRows(allIds);\r\n\r\n    // Trigger custom event for select all action\r\n    this.eventManager.trigger('selectAll', { \r\n      selectedIds: allIds, \r\n      selectedData: allData,\r\n      count: allData.length \r\n    });\r\n\r\n    return allData.length;\r\n  }\r\n\r\n  /**\r\n   * Destroy the table and clean up all resources\r\n   */\r\n  destroy() {\r\n    // Clean up virtual scrolling\r\n    if (this.virtualScrollManager) {\r\n      this.virtualScrollManager.destroy();\r\n    }\r\n\r\n    // Clean up other managers\r\n    if (this.selectionManager) {\r\n      this.selectionManager.destroy && this.selectionManager.destroy();\r\n    }\r\n\r\n    if (this.searchManager) {\r\n      this.searchManager.destroy && this.searchManager.destroy();\r\n    }\r\n\r\n    if (this.filterManager) {\r\n      this.filterManager.destroy && this.filterManager.destroy();\r\n    }\r\n\r\n    if (this.sortingManager) {\r\n      this.sortingManager.destroy && this.sortingManager.destroy();\r\n    }\r\n\r\n    if (this.paginationManager) {\r\n      this.paginationManager.destroy && this.paginationManager.destroy();\r\n    }\r\n\r\n    // Clear container\r\n    if (this.container) {\r\n      this.container.innerHTML = '';\r\n    }\r\n\r\n    // Clear references\r\n    this.virtualScrollManager = null;\r\n    this.selectionManager = null;\r\n    this.searchManager = null;\r\n    this.filterManager = null;\r\n    this.sortingManager = null;\r\n    this.paginationManager = null;\r\n    this.dataManager = null;\r\n    this.renderer = null;\r\n    this.eventManager = null;\r\n  }\r\n\r\n  /**\r\n   * Destroy table and clean up event listeners\r\n   */\r\n  destroy() {\r\n    // Clean up any event listeners\r\n    const paginationContainer = this.container.querySelector('.tablix-pagination');\r\n    if (paginationContainer) {\r\n      paginationContainer.removeEventListener('click', this._paginationClickHandler);\r\n    }\r\n\r\n    // Destroy managers\r\n    if (this.selectionManager) {\r\n      this.selectionManager.destroy();\r\n    }\r\n\r\n    // Clear container\r\n    this.container.innerHTML = '';\r\n    \r\n    // Clear references\r\n    this.dataManager = null;\r\n    this.renderer = null;\r\n    this.eventManager = null;\r\n    this.paginationManager = null;\r\n    this.sortingManager = null;\r\n    this.selectionManager = null;\r\n  }\r\n}","import Table from './core/Table.js';\r\n\r\n// Export main Table class as default\r\nexport default Table;\r\n\r\n// Named exports for convenience\r\nexport { Table };\r\n\r\n// Version info\r\nexport const version = '0.1.0';\r\n"],"names":["DataManager","constructor","table","data","this","originalData","filteredData","currentFilters","currentSorts","serverTotalRows","getData","setData","paginationManager","updatePaginationInfo","setServerData","totalRows","getTotalRows","length","applyFilter","criteria","Object","keys","filter","item","entries","every","key","value","toLowerCase","includes","resetToFirstPage","setFilteredData","applySorting","sorts","sortingManager","_applySorting","sort","a","b","column","direction","aVal","bVal","comparison","clearFilters","clearSorting","getPageData","page","pageSize","start","slice","Renderer","renderTable","virtualMode","columns","columnManager","getColumns","options","controlsOptions","controls","isVirtualScrollEnabled","virtualScrollManager","isEnabled","preservedSearchValue","searchInputHadFocus","cursorPosition","existingSearchInput","container","querySelector","document","activeElement","selectionStart","html","selectionManager","enabled","mode","position","renderControls","virtualScroll","containerHeight","forEach","col","isSortable","_isColumnSortable","sortDirection","_getSortDirection","name","title","row","index","globalIndex","currentPage","cell","renderedCell","result","formatCellValue","isHtml","escapeHtml","renderer","innerHTML","newSearchInput","renderPagination","bindControlEvents","searchManager","bindEvents","bindSortEvents","bindRowClickEvents","filterUI","renderFilterIcons","requestAnimationFrame","focus","setSelectionRange","eventManager","trigger","paginationContainer","info","getInfo","undefined","totalPages","showPageSizes","startRow","endRow","pageSizeOptions","size","showFirstLast","showPrevNext","hasPrevPage","showPageNumbers","getPageNumbers","hasNextPage","isLoading","bindPaginationEvents","addEventListener","async","e","target","classList","contains","disabled","preventDefault","parseInt","dataset","isNaN","goToPage","error","console","pageSizeSelect","newPageSize","changePageSize","text","div","createElement","textContent","renderLoading","renderError","message","searchOptions","search","placeholder","pagination","currentPageSize","refresh","wrapper","action","firstPage","prevPage","nextPage","lastPage","handleRefresh","handleExport","onRefresh","newData","loadData","refreshTable","csv","map","join","values","replace","blob","Blob","type","url","URL","createObjectURL","href","download","body","appendChild","click","removeChild","revokeObjectURL","format","headerRow","th","closest","columnName","toggleSort","tbody","globalRowIndex","rowIndex","localRowIndex","currentData","getCurrentPageData","rowData","originalEvent","dataManager","updateSortIndicators","currentSort","querySelectorAll","isSorted","remove","indicator","arrow","add","setAttribute","removeAttribute","isColumnSortable","getSortDirection","EventManager","events","on","event","callback","push","off","indexOf","splice","clear","payload","cb","PaginationManager","maxPageNumbers","serverDataLoader","init","Math","ceil","getClientPageData","getServerPageData","Error","filters","pageNumber","targetPage","max","min","oldPage","newPage","oldPageSize","floor","pageData","maxPages","pages","end","i","unshift","setEnabled","setMode","SortingManager","serverSortLoader","defaultSortType","caseSensitive","nullsFirst","sortOrder","sortTypes","auto","_autoSort","bind","string","_stringSort","number","_numberSort","date","_dateSort","boolean","_booleanSort","_sortServer","_sortClient","currentIndex","nextDirection","warn","find","_compareValues","sortFunction","sortType","numA","parseFloat","numB","dateA","Date","dateB","isDateLike","str","test","String","strA","trim","strB","localeCompare","sensitivity","boolA","getSortState","setOptions","newOptions","sortable","ColumnManager","formatters","Map","supportedFormats","initializeColumns","prepareColumn","compileFormatters","prepared","formatter","createFormatter","set","locale","formatOptions","formatText","formatDate","formatCurrency","currency","formatNumber","formatPercent","getColumn","get","formattedValue","getTime","Intl","DateTimeFormat","numericValue","Number","style","NumberFormat","registerFormat","formatType","formatterFactory","log","getSupportedFormats","FilterManager","serverFilterLoader","debounceDelay","showBadges","showTooltips","columnFilters","operators","none","label","apply","isEmpty","isNotEmpty","equals","filterValue","notEquals","beginsWith","startsWith","endsWith","notContains","debounceTimer","openDropdowns","Set","filterConfig","validateFilterConfig","beforeFilterData","getActiveFilters","config","isActive","isFilterActive","_filterServer","_filterClient","updateFilterIndicators","activeFilters","clearFilter","has","delete","clearAllFilters","filterState","getColumnUniqueValues","Array","from","getColumnFilter","hasColumnFilter","isArray","conditions","cond","operator","some","_testRowAgainstFilter","cellValue","condition","header","hasFilter","filterIndicator","_updateFilterBadge","badge","badgeText","activeConditions","className","registerOperator","getOperators","FilterUI","filterManager","activeDropdown","handleDocumentClick","handleFilterIconClick","destroy","removeEventListener","closeAllDropdowns","thContent","stopPropagation","sortIndicator","insertBefore","nextSibling","dropdown","createFilterDropdown","showDropdown","renderDropdownContent","bindDropdownEvents","currentFilter","renderValueFilterPanel","renderConditionFilterPanel","uniqueValues","selectedValues","isChecked","renderConditionRow","needsValue","op","tab","switchTab","bindValueFilterEvents","bindConditionFilterEvents","valuePanel","searchInput","searchTimeout","clearTimeout","setTimeout","filterValueList","selectAllCheckbox","toggleSelectAll","checked","checkbox","updateSelectAllState","conditionPanel","addButton","addCondition","bindConditionRowEvents","select","valueInput","parentElement","button","conditionRow","operatorSelect","tabType","toggle","panel","searchTerm","items","term","matches","display","checkboxes","visibleCheckboxes","checkedCount","indeterminate","conditionsContainer","conditionHtml","children","insertAdjacentHTML","newCondition","lastElementChild","collectValueFilter","collectConditionFilter","conditionRows","triggerRect","getBoundingClientRect","dropdownRect","left","top","bottom","width","window","innerWidth","height","innerHeight","SearchManager","searchDelay","searchColumns","minLength","currentSearchTerm","handleSearchInput","handleSearchClear","source","performSearch","searchClear","clearSearch","updateClearButtonVisibility","previousTerm","hadFocus","willSearch","filterData","afterSearchData","resultsCount","totalCount","isSearchActive","searchPerformed","getSearchableColumns","updateInputValue","setSearchTerm","getSearchTerm","getSearchInfo","configure","oldOptions","getConfiguration","SelectionManager","selectedRows","lastSelectedRow","rowIdMap","dataIdKey","dragSelection","startRowIndex","currentRowIndex","startRowId","originalSelection","isDragging","dragThreshold","eventListenersSetup","setupEventListeners","handleRowClick","setupDragSelection","clearSelection","updateSelectionAfterDataChange","updateUI","rowId","getRowId","hasOriginalEvent","ctrlKey","shiftKey","metaKey","timestamp","now","beforeSelectEvent","currentSelection","isCtrlClick","isShiftClick","isDragSelection","handleSingleSelection","handleMultiSelection","afterSelectEvent","selectedData","getSelectedData","selectionSize","handleRangeSelection","endRowId","fullData","getFullData","startIndex","findIndex","endIndex","minIndex","maxIndex","tableElement","startX","startY","clientX","clientY","abs","startDragSelection","updateDragSelection","completeDragSelection","cancelDragSelection","tableWrapper","dragStart","applyDragSelection","dragComplete","resetDragSelection","createRowHash","JSON","stringify","hash","charCodeAt","allRows","hasAttribute","virtualIndex","getAttribute","allDataRowIds","newSelection","getSelectedIds","selectRows","rowIds","ids","id","deselectRows","hadSelection","isRowSelected","isRowSelectedByData","getSelectionCount","enable","disable","oldMode","lastSelected","VirtualScrollManager","buffer","rowHeight","throttleDelay","scrollContainer","tableBody","topSpacer","bottomSpacer","visibleStart","visibleEnd","renderedStart","renderedEnd","performanceData","renderTimes","scrollUpdates","lastMeasurement","throttledScrollHandler","throttle","handleScroll","immediateScrollHandler","updateScheduled","pendingUpdate","lastScrollTime","scrollVelocity","renderedData","setupScrollContainer","detectRowHeight","calculateViewport","scheduleUpdate","handleScrollImmediate","passive","handleScrollStart","handleScrollEnd","handleResize","setupEventDelegation","setupSelectionListeners","rowClickHandler","justFinishedDrag","eventType","element","updateSelectionStates","setupVirtualDragSelection","rowHoverHandler","createSpacers","existingTop","existingBottom","cssText","firstChild","sampleRow","renderSingleRow","rect","scrollTop","visibleRowCount","updateSpacers","bottomHeight","performance","lastScrollTop","timeDelta","isScrollbarDragging","scrollDragInterval","setInterval","clearInterval","isDragSelecting","dragStartIndex","dragStartX","dragStartY","applyVirtualDragSelection","handleMouseUp","update","startTime","renderVisibleRows","endTime","trackPerformance","fragment","createDocumentFragment","handleImageLoading","img","complete","cloneNode","src","handleLoad","opacity","handleError","transition","originalIndex","tr","td","rendered","updateData","scrollToRow","getVisibleRange","getRenderedData","renderTime","shift","getPerformanceStats","times","avg","reduce","averageRenderTime","toFixed","maxRenderTime","minRenderTime","visibleRows","renderedRows","func","limit","inThrottle","arguments","debug","Table","sorting","filtering","export","selection","initialData","dataToRender","_fetchFromUrl","fetch","response","ok","status","statusText","json","getPaginationInfo","setPaginationEnabled","setPaginationMode","clearEvents","getOriginalData","getOptions","enableSelection","disableSelection","setSelectionMode","selectAllRows","allData","allIds","selectedIds","count","_paginationClickHandler"],"mappings":"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"}